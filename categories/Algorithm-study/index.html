<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>分类: Algorithm study - KONGJUNE&#39;s BLOG</title>


    <meta property="og:type" content="website">
<meta property="og:title" content="KONGJUNE&#39;s BLOG">
<meta property="og:url" content="http://kongjune.com/categories/Algorithm-study/index.html">
<meta property="og:site_name" content="KONGJUNE&#39;s BLOG">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://kongjune.com/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KONGJUNE&#39;s BLOG">
<meta name="twitter:image" content="http://kongjune.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?3172a16c5e2815ee0db72abc363d939a";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>



    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    
    <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <div class="toBeDraged"></div>
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="KONGJUNE&#39;s BLOG" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">主页</a>
                
                <a class="navbar-item"
                href="/archives">档案</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/about">关于 &amp; 友链</a>
                
                <a class="navbar-item"
                href="/mc">Minecraft</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/categories">分类</a></li>
            
            <li class="is-active"><a href="#" aria-current="page">Algorithm study</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/08/14/马拉车算法/" class="image is-7by1">
            <img class="thumbnail" src="/img/马拉车算法/banner.jpg" alt="算法学习：马拉车算法">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-14T08:55:52.000Z">2019-08-14</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11 分钟 读完 (大约 1648 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/14/马拉车算法/">算法学习：马拉车算法</a>
            
        </h1>
        <div class="content">
            <blockquote>
<p>学习自博客：</p>
<ul>
<li><a href="https://www.cnblogs.com/love-yh/p/7072161.html" target="_blank" rel="noopener">https://www.cnblogs.com/love-yh/p/7072161.html</a></li>
<li><a href="https://blog.csdn.net/happyrocking/article/details/82622881" target="_blank" rel="noopener">https://blog.csdn.net/happyrocking/article/details/82622881</a></li>
</ul>
</blockquote>
<p><strong>马拉车算法</strong>（音译，Manacher’s algorithm）是一个复杂度为 $O(n)$ 的、求一个字符串最长回文子序列的算法。</p>
<p>回文字符串，就是指无论从左向右读还是从右向左读结果都是一样的字符串。如字符串<code>google</code>的最长回文字串为<code>goog</code>。</p>
<p>极限暴力的求得字符串最长回文字序列的方法都是寻找每个中心点开始向两边扩延一位一位地看是否相同，这样的算法复杂度回到 $O(n^2)$，显然不满足一般的需求。且由于回文字符串长度的奇偶问题，还需要特别的奇偶分类问题：如回文字符串<code>aba</code>的中心是<code>b</code>这个字母，回文字符串<code>abba</code>的中心是两个<code>b</code>之间。这两种情况需要分别考虑。</p>
<h2 id="马拉车算法思想"><a href="#马拉车算法思想" class="headerlink" title="马拉车算法思想"></a>马拉车算法思想</h2><h3 id="去除字符串长度奇偶分类的问题"><a href="#去除字符串长度奇偶分类的问题" class="headerlink" title="去除字符串长度奇偶分类的问题"></a>去除字符串长度奇偶分类的问题</h3><p>马拉车首先在每两个字符之间（包括首尾两端）插入一个原字符串没有的特殊符号，比如<code>#</code>。假设我们现在的字符串为<code>google</code>，插入<code>#</code>后便转换为了：<code>#g#o#o#g#l#e#</code>。设字符串长度为 $len$，加入的特殊字符个数一定为 $len +  1$，而 $len$ 与 $len + 1$ 中必为一奇一偶，所以结果一定是一个奇数，这样的话部分回文字符串（如<code>#g#o#o#g#</code>）的中心一定会是一个字符而不是两字符中间。</p>
<h3 id="半径数组"><a href="#半径数组" class="headerlink" title="半径数组"></a>半径数组</h3><p>设原来的字符串为 $str$，加上特殊字符处理后的字符串为$strM$。为了记录每一位对应的最长回文字串半径，我们引入与 $strM$ 半径数组 $p[]$，其中 $p[i]$ 表示以 $strM[i]$ 为中心的最长回文字串的半径，如果 $p[i] = 1$ 就说明该回文串就是 $strM[i]$ 本身。如例子<code>#g#o#o#g#l#e#</code>，可得到如下表格：</p>
<table>
<thead>
<tr>
<th align="center">$i$</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$strM[i]$</td>
<td align="center">#</td>
<td align="center">g</td>
<td align="center">#</td>
<td align="center">o</td>
<td align="center">#</td>
<td align="center">o</td>
<td align="center">#</td>
<td align="center">g</td>
<td align="center">#</td>
<td align="center">l</td>
<td align="center">#</td>
<td align="center">e</td>
<td align="center">#</td>
</tr>
<tr>
<td align="center">$p[i]$</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>可以观察到，$p[i] - 1$ 就是以第 $i$ 位为中心的回文字串在原字符串中的长度。假设在原字符串中，该回文字符串的长度 $l$，由于加入了 $l+ 1$ 个<code>#</code>，在新字符串中的长度就会变为 $ln = 2 \times l + 1$。而 $p[i]$ 存储的是新的字符串的回文字串的半径，也就是 $\frac{ln + 1}{2}$ $=$ $l + 1$，即 $p[i] = l + 1$，所以最终结果为 $p[i] - 1$。</p>
<p>由于字符串的最开始与最后都有一个<code>#</code>字符，为了在搜索回文字串时避免总是判断是否越界，我们在字符串的左端与右端都加上另外一个特殊字符，如<code>$</code>与<code>^</code>。（其实最后一位处不需要加上这个特殊字符，因为字符串的最后本来就是有一位<code>\0</code>用以标记字符串的结束的。）</p>
<p>所以这个算法的重点就在于如何计算数组 $p[]$ 的值。</p>
<h2 id="p-数组求解"><a href="#p-数组求解" class="headerlink" title="$p[]$ 数组求解"></a>$p[]$ 数组求解</h2><p>引入两个变量，分别为<code>id</code>与<code>mx</code>。其中<code>id</code>为一个已经检查过了的最大的回文字符串的中心点，<code>mx</code>为这个回文字符串的最终点。在马拉车算法的过程中，我们不断的对这两个变量进行更新。在这个过程中，我们有公式：<br>$$<br>p[i] = \min(mx - i, p[2\times id - i])<br>$$<br>现在我们就重点来讲解这个公式，如下图所示（其中 $j$ 是 $i$ 关于 $id$ 的对称点（$j = 2\times id - i$），<font color="#5B9BD5">蓝色</font>串➀为以 $j$ 为中心的回文串，<font color="#ED7D31">橙色</font>串为以 $i$ 为中心的回文串，<font color="#92D050">绿色</font>串为以 $id$ 为中心的回文串）：</p>
<p><img src="/img/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/1565748502350.png" alt="1565748502350"></p>
<p>目前我们已经求得了满足 $0 \leq x \leq i - 1$ 的 $p[x]$，接下来就是要使用以前的数据推得 $p[i]$。会有如下情况</p>
<ol>
<li><p>$i \leq mx$</p>
<p>由于 $j$ 与 $i$ 关于 $id$ 对称，所以以 $j$ 为中心的回文串关于 $id$ 对称一下就成了以 $i$ 为中心的回文串。所以我们这个时候需要判断一下情况：</p>
<ol>
<li>如果<font color="#ED7D31">橙色</font>串的末尾没有超过 $mx$， 即 $p[j] \leq mx - i$，此时 $p[i] = p[j]$。</li>
<li>如果<font color="#ED7D31">橙色</font>串的末尾超过了$mx$，即 $p[j] &gt; mx - i$，此时就不能确定 $p[i] = p[j]$ 一定会成立了。则先赋值 $p[i] = mx - i$ ，然后手动向两边扩来得到最长回文子串。为什么 $p[j] = mx -i + 1$  的情况归到了这里？因为当 $p[j] = mx -i + 1$，我们的回文子串直接定到了 $mx$ 上，我们不能确定 $mx$ 以后的位是否还能满足关于 $i$ 回文。</li>
</ol>
</li>
<li><p>$i &gt; mx$</p>
<p>那我们只能保证 $mx - i $ 这一段是满足的，所以我们就先让 $p[i] = mx -i$，其余部分使用笨方法慢慢扩张。</p>
</li>
</ol>
<p>有没有可能<font color="#ED7D31">橙色</font>串的左端超过了 $mx$ 的对称点呢？不可能。如果说左端超过了 $mx$ 的对称点，且中心位于 $i$ 的话，则 $i$ 为中心的回文字串长度会超过以 $id$ 为中心的回文字串，也就是说以 $j$ 为中心的回文子串长度超过了 $id$ 为中心的回文字串，那么我的 $id$ 在之前应该被更新为 $j$。所以这种情况是不存在的。</p>
<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">Manacher</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-comment">/*改造字符串*/</span></span><br><span class="line">    <span class="hljs-built_in">string</span> res=<span class="hljs-string">"$#"</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">int</span>)str.length(); ++i) &#123;</span><br><span class="line">        res += str[i];</span><br><span class="line">        res += <span class="hljs-string">"#"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/*数组*/</span></span><br><span class="line">    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; p(res.length(), <span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> mi = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;   <span class="hljs-comment">//mi为最大回文串对应的中心点，right为该回文串能达到的最右端的值</span></span><br><span class="line">    <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>, maxPoint = <span class="hljs-number">0</span>;    <span class="hljs-comment">//maxLen为最大回文串的长度，maxPoint为记录中心点</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; res.length(); ++i)&#123;</span><br><span class="line">        p[i] = (right &gt; i)? min(p[<span class="hljs-number">2</span> * mi - i], right - i) : <span class="hljs-number">1</span>;     <span class="hljs-comment">//关键句，文中对这句以详细讲解</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">while</span>(res[i + p[i]] == res[i - p[i]])</span><br><span class="line">            ++p[i];</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span>(right &lt; i + p[i])    <span class="hljs-comment">//超过之前的最右端，则改变中心点和对应的最右端</span></span><br><span class="line">        &#123;</span><br><span class="line">            right = i + p[i];</span><br><span class="line">            mi = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(maxLen &lt; p[i])     <span class="hljs-comment">//更新最大回文串的长度，并记下此时的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            maxLen = p[i];</span><br><span class="line">            maxPoint = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> str.substr((maxPoint - maxLen) / <span class="hljs-number">2</span>, maxLen - <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/08/06/扩展KMP/" class="image is-7by1">
            <img class="thumbnail" src="/img/扩展KMP/banner.jpg" alt="算法学习：扩展KMP">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-06T14:33:09.000Z">2019-08-06</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    7 分钟 读完 (大约 1064 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/06/扩展KMP/">算法学习：扩展KMP</a>
            
        </h1>
        <div class="content">
            <p>2019年8月5日下午，冰冷的雨滴击打着脆弱的窗户玻璃，机房里异常的安静，仿佛每个人都等待着一轮风暴。HDU的第五场多校赛已经过去了一半，距离吃饭只有两个半小时了，但我却没有一点开心的感觉。抬头，映入眼帘的就是一道魔鬼签到题目，和红色背景白色字体的“（-5）”字眼。机房的空调从来没有这么好使过，我甚至感到浑身寒冷，有几分想要颤抖身体。</p>
<p>比赛还是如期地结束了。这场比赛的这个签到题我还是没能做出来。是的，爆零了。我开始怀疑人生，怀疑自己存在的意义。挫败的我打开了题解，发现了这个叫做”扩展KMP“算法。虽然忧伤，但我还是尝试学习一下这个算法。于是……</p>
<p><strong>题解传送门</strong>：<a href="https://www.kongjune.com/2019/08/07/HDU6629/" target="_blank" rel="noopener">🚪</a></p>
<h2 id="算法引入"><a href="#算法引入" class="headerlink" title="算法引入"></a>算法引入</h2><p>假设现在有两个字符串，分别为 $S$ 与 $T$ ，其中 $S$ 为待匹配的串，$T$ 为进行匹配的串，现在我需要知道 $S$ 的每一位开始，分别可以匹配成功 $T$ 串中从头开始的连续的多长子串。</p>
<p>举个例子，比如现在 $S$ 为字符串<code>AAAAABBB</code>， $T$ 为字符串<code>AAAAAC</code>。我们定义数组<code>extend[]</code>为最终结果，其中 $extend[i]$ 为 $S.\mathrm{substr}(i,n)$ （$S[i \cdots n-1]$） 中与 $T$ 匹配成功的最长相同前缀的长度。如本例中可得到如下表格：</p>
<table>
<thead>
<tr>
<th align="center">$i$</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$S$</td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>B</code></td>
<td align="center"><code>B</code></td>
<td align="center"><code>B</code></td>
</tr>
<tr>
<td align="center"><code>extend[i]</code></td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>如果使用暴力进行这个匹配过程的话，算法复杂度就达到了 $O(m\times n)$，所以我们要用更好的算法来解决这个问题。这就是扩展 KMP 的任务。</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="我们为何引入并使用next-数组"><a href="#我们为何引入并使用next-数组" class="headerlink" title="我们为何引入并使用next[]数组"></a>我们为何引入并使用<code>next[]</code>数组</h3><p>暴力算法的问题就在于<code>extend[]</code>数组中的数据彼此之间是会有一些联系的，而暴力法并没有用上这些联系而直接进行了重新匹配。</p>
<p>假设我们现在匹配到了第 $i$ 个位置，如下图：</p>
<p><img src="/img/%E6%89%A9%E5%B1%95KMP/1565080573726.png" alt="1565080573726"></p>
<p>其中图中 $p$ 指从 $S$ 的第 $a$ 位开始与 $T$ 匹配成功的最后一位的下一位，也就是说 $S.\mathrm{substr}(a,p) = T.\mathrm{substr}(0,p-a)$。如果从 $i$ 开始的几位与 $T$ 开头的几位相同，那么 $extend[i]$ 的值就是这段距离的长度。所以我们引入 <code>next[]</code>数组来记录匹配串 $T$ 中相同前缀部分的长度。比如对于<code>AAAAAC</code>，我们就可以得到以下列表：</p>
<table>
<thead>
<tr>
<th align="center">$i$</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$T$</td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>C</code></td>
</tr>
<tr>
<td align="center"><code>next[i]</code></td>
<td align="center">6</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>从头开始遍历 $S$，设当前遍历到了第 $i$ 位，$i + next[i -a ]$ 的值会有以下几种情况：</p>
<p><strong>注意</strong>：<code>next[]</code>数组</p>
<ol>
<li><p>$i + next[i - a] &lt;p$</p>
<p><img src="/img/%E6%89%A9%E5%B1%95KMP/1565095531149.png" alt="1565095531149"></p>
<p>说明这个时候的 $i + next[i-a]$ 还在可控范围内。因为我们已经知道了 $S.\mathrm{substr}(a, p)$ 与 $T.\mathrm{substr}(0, p-a)$ 相同，而 $S[i + next[i -a]]$ 还在 $S.\mathrm{substr}(a, p)$ 的范围内，所以这个时候 $S.\mathrm{substr}(i, i + next[i - a])$ 与 $T.\mathrm{substr}(i - a, i - a + next[i - a])$ 就可以成立，于是 $S.\mathrm{substr}(i, i + next[i - a])$ 与 $T.\mathrm{substr}(0, next[i - a])$ 就会成立，所以我们就可以知道 $extend[i]$ 的值为 $next[i - a]$。</p>
</li>
<li><p>$i + next[i - a]  = p$</p>
<p><img src="/img/%E6%89%A9%E5%B1%95KMP/1565095544744.png" alt="1565095544744"></p>
<p>这种情况下，$S[p]$ 与 $T[p - a]$ 不一定相同，$T[p - i]$ 与 $T[p - a]$ 也不一定相同，但却有 $T[p - a]$ 与 $S[p]$ 相同的情况，所以我们就直接对比 $S[p]$ 与 $T[p - a]$ 及以后。然后得到 $next[i]$ 的值。当我最后匹配直到 $S[p + k]$ 与 $T[p+k-a]$ 相同，则可得到 $next[i]$ 的值为 $p + k - i$。下一次再匹配时，只需要从 $a = i$、$p = p + k$ 开始就可以了。</p>
</li>
<li><p>$i + next[i - a] &gt; p$</p>
<p><img src="/img/%E6%89%A9%E5%B1%95KMP/1565097429456.png" alt="1565097429456"></p>
<p>这种情况下我们就不能确定这上面的匹配方式相同了，所以我们就需要从 $S[p]$ 与 $T[p - i]$ 开始匹配，具体做法同第 $2$ 种情况。</p>
</li>
</ol>
<h3 id="获得next-数组"><a href="#获得next-数组" class="headerlink" title="获得next[]数组"></a>获得<code>next[]</code>数组</h3><p>其实这个就很简单了。<code>next[]</code>数组反映的即是 $T$ 字符串中从第 $i$ 位开始的内容与从第 $0$ 位内容开始的最大相同前缀，所以其实只是把 $T$ 与自己匹配跑了一编这个算法。</p>
<h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> next[<span class="hljs-number">100</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> extend[<span class="hljs-number">100</span>];</span><br><span class="line"><span class="hljs-built_in">string</span> S, T;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> m = T.length();</span><br><span class="line">    <span class="hljs-comment">// m:T的长度</span></span><br><span class="line">    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, p = <span class="hljs-number">0</span>;</span><br><span class="line">    next[<span class="hljs-number">0</span>] = m;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i &gt;= p) p = i;</span><br><span class="line">            <span class="hljs-keyword">while</span> (p &lt; m &amp;&amp; T[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line">            next[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            next[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getExtend</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> n = S.length();</span><br><span class="line">    <span class="hljs-keyword">int</span> m = T.length();</span><br><span class="line">    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, p = <span class="hljs-number">0</span>;</span><br><span class="line">    getNext();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p) &#123;</span><br><span class="line">            <span class="hljs-comment">// i &gt;= p 的作用：举个典型例子，S 和 T 无一字符相同</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (i &gt;= p) p = i;</span><br><span class="line">            <span class="hljs-keyword">while</span> (p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line">            extend[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            extend[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/07/30/离散化/" class="image is-7by1">
            <img class="thumbnail" src="/img/离散化/banner.jpeg" alt="算法学习：离散化">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-30T06:14:49.000Z">2019-07-30</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5 分钟 读完 (大约 783 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/07/30/离散化/">算法学习：离散化</a>
            
        </h1>
        <div class="content">
            <blockquote>
<p>Banner 图源网络，侵删。</p>
</blockquote>
<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p><strong>离散化</strong>：将无限空间中的有限个体映射到有限的空间中。</p>
<p>比如说我有一个无尽的坐标轴，上面有 $10^4$ 个点，每个点的坐标值可以很大很大接近无限。如果我想知道比其中一个点小的点有多少个，暴力比较每个点的坐标值则会因为数据过大而 Boom。而我们通过点与点相对关系，将点的值进行重新赋值，则可以大大减小算法的复杂度。</p>
<p>比如，我现在的数轴上只有6个点， 他们的坐标分别为 $0$、$610$、$10^5+2$、$99$、$5$、$10^9+45$，如果我只是按照他们原有的值进行比较，最大要比较到 $10^9+45$。而如果我们用他们的相对大小来进行比较，即转换为 $0$、$3$、$4$、$2$、$1$、$5$ 则会方便很多。这就是离散化的思想，<strong>就是将离散的事物进行重新分配</strong>。</p>
<h2 id="离散化方法：排序-二分"><a href="#离散化方法：排序-二分" class="headerlink" title="离散化方法：排序+二分"></a>离散化方法：排序+二分</h2><p>（推荐使用本方法）</p>
<p>基本原理就是排序后使用STL中的<code>unque()</code>函数来获取整体数据不同元素的个数，然后在已排序序列二分查找 $num[i]$ 的值，从而得到对 $num[i]$ 对应的值，然后进行重新赋值。</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    disc[i] = num[i]; <span class="hljs-comment">// num:原数据数组，disc:离散化后的数组</span></span><br><span class="line">&#125;</span><br><span class="line">sort(disc, disc + n);</span><br><span class="line">cnt = unique(disc, disc + n) - disc; <span class="hljs-comment">// STL中的unique函数，具体内容见👇</span></span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)</span><br><span class="line">    num[i] = lower_bound(disc, disc + n, num[i]) - disc;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>unique(a, b)</code>函数：STL中比较常见的函数，他的功能是“删除”序列中所有<strong>相邻的</strong>重复元素（只保留一个），因为只是处理相邻的重复元素所以在使用这个函数之前要进行排序。（此处略去更具体的<del>都能再写一页博客的</del>内容）。其中参数<code>a</code>,<code>b</code>为指针，类似<code>sort()</code>函数中的参数。</li>
<li><code>lower_bound(a, b, v)</code>函数：二分查找返回<code>a</code>、<code>b</code>指针之间空间中大于等于 $v$ 的第一个迭代器。</li>
</ul>
<h2 id="离散化方法：排序-暴力"><a href="#离散化方法：排序-暴力" class="headerlink" title="离散化方法：排序+暴力"></a>离散化方法：排序+暴力</h2><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_N 1e5+5  <span class="hljs-comment">// 根据实际问题调整</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> data;</span><br><span class="line">    <span class="hljs-keyword">int</span> index;</span><br><span class="line">&#125;num[MAX_N];</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a.data &lt; b.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> rank[MAX_N], n;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num[i].data);</span><br><span class="line">        num[i].index = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num, num + n, cmp);</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        rank[num[i].id] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序之后按照原顺序进行赋值，相同元素就会出现离散化不成同一元素的情况，所以不推荐这种方法。</p>
<hr>
<p>听大佬说<a href="https://www.luogu.org/problem/P1955" target="_blank" rel="noopener">洛谷P1955</a>是一道有关离散化的题，<del>我这个蒟蒻还没有做。🙃</del></p>
<p><del>有时间做了再搞题解什么的。🙃</del></p>
<p><strong>题解我搞出来了，传送门：<a href="https://www.kongjune.com/2019/07/30/P1955/" target="_blank" rel="noopener">🚪</a></strong></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/07/28/后缀数组/" class="image is-7by1">
            <img class="thumbnail" src="/img/后缀数组/banner.jpeg" alt="算法学习：后缀数组">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-28T06:03:08.000Z">2019-07-28</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    6 分钟 读完 (大约 895 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/07/28/后缀数组/">算法学习：后缀数组</a>
            
        </h1>
        <div class="content">
            <blockquote>
<p>学习自：</p>
<ul>
<li><a href="https://www.cnblogs.com/victorique/p/8480093.html#autoid-0-0-0" target="_blank" rel="noopener">https://www.cnblogs.com/victorique/p/8480093.html#autoid-0-0-0</a></li>
<li><a href="https://blog.csdn.net/Tiw_Air_Op1721/article/details/81275953?comment_content=提醒填坑&comment_replyId=&article_id=81275953&comment_userId=&commentId=" target="_blank" rel="noopener">https://blog.csdn.net/Tiw_Air_Op1721/article/details/81275953?comment_content=%E6%8F%90%E9%86%92%E5%A1%AB%E5%9D%91&amp;comment_replyId=&amp;article_id=81275953&amp;comment_userId=&amp;commentId=</a></li>
</ul>
</blockquote>
<h2 id="后缀数组简介"><a href="#后缀数组简介" class="headerlink" title="后缀数组简介"></a>后缀数组简介</h2><p><strong>后缀</strong>：从字符串某个位置 $i$ 到字符串末尾的子串，我们定义以字符串 $str$ 的第 $i$ 位为第一个元素的后缀为<code>suff[i]</code>。（后缀的英文：<em>suffix</em>）</p>
<p><strong>后缀数组</strong>：把字符串 $str$ 的每一个后缀按照字典序排序后所形成的数组。</p>
<h2 id="后缀数组的实现"><a href="#后缀数组的实现" class="headerlink" title="后缀数组的实现"></a>后缀数组的实现</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><ul>
<li><code>suff[]</code>数组，用来记录从第 $i$ 位开始的后缀</li>
<li><code>sa[]</code>数组（<em>suffix array</em>），存储的是字典第 $i$ 小的后缀的<strong>下标</strong>。比如<code>sa[0] = 8</code>代表的是<code>suff[]</code>数组中第 $8$ 位后缀在字典序中最小。而<code>suff(sa[0])</code>才真正存储这最小的那个后缀的内容。</li>
<li><code>rank[]</code>数组，与<code>sa[]</code>相反，存储的是下标为 $i$ 的后缀为第几小。一定存在关系 $\text{rank}[\text{sa}[i]] = i$。</li>
</ul>
<h3 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h3><p>问题在于我们怎么给这个后缀数组排序，如果强硬 sort 的话，sort 算法复杂度本来就有 $O(n\log_2n)$ 字符串排序还不用于一般数字的排序，每个字符串对比还有 $O(n)$ 复杂度。也就是说用 sort 的话，复杂度会达到 $O(n^2\log_2n)$。这就很伤不是么，所以我们要想出来一个复杂度更低的算法。</p>
<p>我们知道，两个字符串的比较，如果前半部分相同则比较结果取决于后半部分的比较结果，否则只需要看前半部分的比较结果。基于这个事实，我们考虑以下方法：</p>
<p>对于字符串 $str$，定义<strong>k-前缀</strong>为：</p>
<p>$$<br>str_k=\begin{cases}<br>str[0\dots k - 1] = str.\mathrm{substr}(0, k) &amp; (k\leq str.\mathrm{length}()) \\<br>str &amp; (k &gt; str.\mathrm{length}())<br>\end{cases}<br>$$<br>然后类似的，我们定义出基于<strong>k-前缀</strong>意义下的<code>sa[]</code>数组和<code>rank[]</code>数组，在这里我们记作 $sa_k$ 与 $rank_k$ 数组。其中 $sa_k$ 为k-前缀意义下的后缀数组，$rank_k$ 为k-前缀意义下的名次数组。则有以下计算方式：</p>
<ul>
<li><p>容易求出 $rank_1$ 的值与 $sa_1$ 的值，只需要进行 sort 对第一个字母排序就可以了。</p>
</li>
<li><p>得到了 $rank_k$，则定义二元组 $(rank_k[i],rank_k[i + k])$，按照“如果 $rank_k[i]$ 相同则比较$rank_k[i +k]$，否则则比较 $rank_k[i]$ ”的方法来进行sort，即可求出 $sa_{2k}$。</p>
</li>
<li><p>求出了 $sa_k$ 则可以很快求出 $rank_k$，有以下关系：<br>$$<br>rank_k[i] = \begin{cases}<br>rank_k[i - 1] &amp; suff[sa[i]]_k = suff[sa[i - 1]]_k \\<br>rank_k[i - 1] + 1 &amp; suff[sa[i]] _ k \neq suff[sa[i - 1]]_k<br>\end{cases}<br>$$</p>
</li>
</ul>
<p>这样的话我们求解的顺序就是：<br>$$<br>sa_1 \  \&amp;  \ rank_1 \rightarrow sa_2 \rightarrow rank_2 \rightarrow sa_4 \rightarrow rank_4 \rightarrow \cdots \rightarrow sa_n \rightarrow rank_n<br>$$<br>当不再出现并列的 $rank$ 的时候就可以结束循环。整个过程如下图所示：</p>
<p><img src="/img/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/1564227558972.png" alt="1564227558972"></p>
<p>每一次排序需要进行 $n\log_2n$ 次比较，每一次比较需要 $O(1)$ 复杂度，总共进行 $\log_2n$ 次比较，因此总时间复杂度为$O(n\log_2^2n)$。</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>这一部分我们要试图探索比 $O(n\log _2^2n)$ 更优的排序算法。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/07/27/线性基（异或和求最大值）/" class="image is-7by1">
            <img class="thumbnail" src="/img/线性基（异或和求最大值）/banner.jpeg" alt="算法学习：线性基">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-27T07:16:16.000Z">2019-07-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    28 分钟 读完 (大约 4217 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/07/27/线性基（异或和求最大值）/">算法学习：线性基</a>
            
        </h1>
        <div class="content">
            <h1 id="线性基-——异或和求最大值"><a href="#线性基-——异或和求最大值" class="headerlink" title="线性基   ——异或和求最大值"></a>线性基   <font size="5">——异或和求最大值</font></h1><blockquote>
<p>学习自博客：<a href="https://blog.sengxian.com/algorithms/linear-basis" target="_blank" rel="noopener">https://blog.sengxian.com/algorithms/linear-basis</a></p>
</blockquote>
<p><strong>基（basis）</strong>是线性代数中的一个概念，他是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素被称为基向量。向量空间中的任意一个元素，都可以唯一地被表示成基向量的线性组合。异或空间基向量，被称为线性基。</p>
<h2 id="从线性代数开始的异或世界"><a href="#从线性代数开始的异或世界" class="headerlink" title="从线性代数开始的异或世界"></a>从线性代数开始的异或世界</h2><h3 id="线性空间（向量空间）"><a href="#线性空间（向量空间）" class="headerlink" title="线性空间（向量空间）"></a>线性空间（向量空间）</h3><p>定义$({\Bbb F},\mathrm V,+,\cdot)$为线性空间（<em>Vector Space</em>）。其中 $\Bbb F$ 为域，其中的元素为标量；$\mathrm V$ 为集合，其中的元素称为向量，有以下两个运算：</p>
<ol>
<li>向量加法：$\mathrm V+\mathrm V\rightarrow \mathrm V$，记作 ${\bf v}+{\bf w},\exists {\bf v},{\bf m} \in \mathrm V$；</li>
<li>标量乘法：${\Bbb F}\cdot \mathrm V\rightarrow \mathrm V$，记作 $a \cdot {\bf v}, \ \exists {\bf a} \in {\Bbb F},{\bf v}\in \mit \mathrm V$</li>
</ol>
<p>且运算满足以下公理：</p>
<ol>
<li>向量加法结合律：${\bf u} + ({\bf v} + {\bf w}) = ({\bf u} + {\bf v} ) + {\bf w}$；</li>
<li>向量加法交换律：${\bf v} + {\bf w} = {\bf w} + {\bf v}$；</li>
<li>向量加法的单位元：$\mathrm V$ 中有一个被称为零向量的 $\bf 0$，$\forall {\bf v}\in \mathrm V$，${\bf v} + {\bf 0} = {\bf v}$；</li>
<li>向量加法的逆元素：$\forall {\bf v}\in \mathrm {V}$，$\exists {\bf w} \in \mathrm V$，使得${\bf v} + {\bf w} = 0$，其中 ${\bf w}$ 称为 ${\bf v}$ 的逆元；</li>
<li>标量乘法与标量的域乘法相容：$a(b{\bf v} ) = (ab){\bf v}$；</li>
<li>标量乘法的单位元：域$\Bbb F$存在乘法单位元 $1$ 满足 $1{\bf v} = {\bf v}$；</li>
<li>标量乘法对向量加法的分配律：$a({\bf u} + {\bf v}) = a{\bf u} + a{\bf v}$；</li>
<li>标量乘法对域加法的分配律：$(a+b){\bf v} = a{\bf v} + b{\bf v}$。</li>
</ol>
<p><strong>基本性质</strong>：</p>
<ul>
<li>零元素 $0$ 是唯一的；</li>
<li>对任意的$a\in {\Bbb F}$，$a \cdot {\bf 0} = {\bf 0}$；</li>
<li>对任意的${\bf u}\in \mathrm V$，${\bf 0}\cdot{\bf u} = {\bf 0}$（ ${\bf 0}$ 是 $\Bbb F$ 的加法单位元）；</li>
<li>如果 $a \cdot {\bf u} = {\bf 0}$，则要么 $a = 0$ ，要么 ${\bf u}  = {\bf 0}$；</li>
<li>向量加法的逆向量 $\bf v$ 是唯一的，记作$-\bf v$。${\bf u} + {- \bf v}$ 也可以写成 ${\bf u} - \bf v$，两者都是标准的；</li>
<li>对 $\forall {\bf u} \in \mathrm V$， $-1\cdot {\bf u}=-{\bf u}$。</li>
<li>对 $\forall a\in \Bbb F$ 以及${\bf u}\in V$，$(-a)\cdot {\bf u} = -(a\cdot {\bf u}) = a \cdot (-{\bf u})$。</li>
</ul>
<p><strong>其他扩展内容</strong>：</p>
<p>最为常见的向量空间的例子是给定了直角坐标系的平面：平面上的每一点 $P$ 都有一个坐标 $P(x,y)$ ，并对应着一个向量 $(x,y)$。所有普通意义上的平面向量组成了一个空间，记作 $\Bbb R^2$（因为每个向量都可以表示为两个实数构成的有序数组$(x,y)$。可以验证，对于普通意义上的向量加法和标量乘法，$\Bbb R^2$ 满足向量空间的所有公理。设所有普通意义上的平面向量记作 $\mathrm V$ ，则 ${\Bbb R}^2 = ({\Bbb R}, \mathrm V,+,\cdot)$。实际上，向量空间是 $\Bbb R^2$ 的推广。</p>
<p>对于通常意义上的多项式加法和标量乘法，所有系数为实数的多项式的集合 $\Bbb R[\bf X]$ 也构成一个向量空间。更广泛的，所有从实数域射到实数域的连续函数的集合 $\mathcal C(\mathbb R,\mathbb R)$也是向量空间</p>
<h3 id="线性无关"><a href="#线性无关" class="headerlink" title="线性无关"></a>线性无关</h3><p>对向量空间中 $\mathrm V$ 上的 $n$ 个元素的向量组 $({\bf v}_1,\dots,{\bf v}_n)$，若存在不全为 $0$ 的数 $a_i\in \mathbb F$，满足：<br>$$<br>a_1{\bf v}_1 + a_2{\bf v_2} + \dots + a_n{\bf v} _ n = 0<br>$$<br>则称 $n$ 个向量<strong>线性相关</strong>（<em>Linearly Dependent</em>），否则称为<strong>线性无关</strong>（<em>Linearly Independent</em>）。</p>
<h3 id="线性组合"><a href="#线性组合" class="headerlink" title="线性组合"></a>线性组合</h3><p>对于向量空间中 $\mathrm V$ 上 $n$ 个元素的向量组 $({\bf v}_1,\dots,{\bf v}_n)$，其<strong>线性组合</strong>（<em>Linear Combination</em>）是如下形式的向量：<br>$$<br>a_1{\bf v_1} + a_2{\bf v}_2 + \dots+a_n{\bf v}_n<br>$$<br>其中 $a_1,\dots,a_n\in \mathbb F$。</p>
<h3 id="张成（Span）"><a href="#张成（Span）" class="headerlink" title="张成（Span）"></a>张成（<em>Span</em>）</h3><p>对于相连空间中 $V$ 上 $n$ 个元素的向量组 $({\bf v}_1,\dots,{\bf v}_n)$，其所有线性组合所构成的集合称为 $({\bf v}_1,\dots,{\bf v}_n)$ 的<strong>张成</strong>（<em>Span</em>），记作$\mathrm{span}(\mathbf{v}_1, \ldots, \mathbf{v}_n)$。</p>
<h3 id="基（Basis"><a href="#基（Basis" class="headerlink" title="基（Basis)"></a>基（<em>Basis</em>)</h3><p><strong>基</strong>（<em>Basis</em>）（也称为<strong>基底</strong>）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为<strong>基向量</strong>。向量空间中任意一个元素，都可以唯一地表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的<strong>维数</strong>。</p>
<p>给定一个向量空间 ${\displaystyle \mathrm {V}}$。${\displaystyle \mathrm {V}}$ 的一组<strong>基</strong> ${\displaystyle {\mathfrak {B}}}$ 是指 ${\displaystyle \mathrm {V} }$ 里面的可线性生成 ${\displaystyle \mathrm {V} }$ 的一个线性无关子集。${\displaystyle {\mathfrak {B}}}$ 的元素称为<strong>基向量</strong>。</p>
<p>更详细来说，设 ${\displaystyle {\mathfrak {B}}={\mathbf e_{1},\mathbf e_{2},\cdots ,\mathbf e_{n}}}$ 是在系数域 ${\displaystyle \mathbb {F}}$（比如实数域 ${\displaystyle \mathbb {R}}$ 或复数域${\displaystyle \mathbb {C}}$）上的向量空间 ${\displaystyle \mathrm {V}}$ 的有限子集。如果 ${\displaystyle {\mathfrak {B}}}$ 满足下列条件：</p>
<ol>
<li>对任意 ${\displaystyle (\lambda_{1},\lambda_{2},\cdots ,\lambda_{n})\in \mathbb {F} ^{n}}$ ，如果 ${\displaystyle \lambda_{1}\mathbf e_{1}+\lambda_{2}\mathbf e_{2}+\cdots +\lambda_{n}\mathbf e_{n}=0}$ 则必然 ${\displaystyle \lambda _{1}=\lambda _{2}=\cdots =\lambda _{n}=0}$；</li>
<li>对任意 ${\displaystyle \mathbf v\in \mathrm {V} }$，可以选择 ${\displaystyle (\lambda_{1},\lambda_{2},\cdots ,\lambda_{n})\in \mathbb {F} ^{n}}$，使得 ${\displaystyle v=\lambda_{1}\mathbf e_{1}+\lambda_{2}\mathbf e_{2}+\cdots +\lambda_{n}\mathbf e_{n}}$。</li>
</ol>
<p>就说 ${\displaystyle {\mathfrak {B}}}$ 是向量空间 ${\displaystyle \mathrm {V} }$ 的一组<strong>基</strong>。</p>
<p><strong>性质</strong>：</p>
<p>设 $\mathfrak {B}$ 是向量空间 $\mathrm V$ 的基。则 $\mathfrak {B}$ 具有以下性质：</p>
<ol>
<li>$\mathrm V$ 是 $\mathfrak {B}$ 的极小生成集，就是说只有 $\mathfrak {B}$ 能张成 $\mathrm  V$，而它的任何<strong>真子集</strong>都不张成全部的向量空间。</li>
<li>$\mathfrak {B}$ 是 $\mathrm  V$ 中<strong>线性无关向量的极大集合</strong>，就是说 $\mathfrak {B}$ 在 $\mathrm  V$ 中是线性无关集合，而且 $\mathrm V$ 中没有其他线性无关集合包含它作为真子集。</li>
<li>$\mathrm V$中所有的向量都可以按唯一的方式表达为 $\mathfrak {B}$ 中向量的线性组合。</li>
</ol>
<p>第三点尤其重要，感性的理解，基就是向量空间中的一个子集，它可以通过唯一的线性组合，来张成向量空间中所有的向量，这样就可以大大的缩小我们向量空间的大小。</p>
<h3 id="线性相关性引理（Linear-Dependent-Lemma）"><a href="#线性相关性引理（Linear-Dependent-Lemma）" class="headerlink" title="线性相关性引理（Linear Dependent Lemma）"></a>线性相关性引理（<em>Linear Dependent Lemma</em>）</h3><p>如果 $(\mathbf{v}_1, \ldots, \mathbf{v}_n)$ 在 $\mathrm V$ 中是线性相关的，并且 $\mathbf{v}_1 \neq 0$，则有至少一个 $j \in {2, \ldots, m}$使得下列成立：</p>
<ol>
<li>$\mathbf{v}_j \in \mathrm{span}(\mathbf{v}_1, \ldots, \mathbf{v}_{j - 1})$；</li>
<li>如果从$ (\mathbf{v}_1, \ldots, \mathbf{v}_n)$ 去掉第 $j$ 项，则剩余向量组的张成仍然等于 $\mathrm{span}(\mathbf{v}_1, \ldots, \mathbf{v_n})$。</li>
</ol>
<p><strong>证明：</strong></p>
<p>设 $(\mathbf{v}_1, \ldots, \mathbf{v}_n)$在 $\mathrm V$ 中是线性相关的，并且 $\mathbf{v}_1 \neq \mathbf{0}$，则有不全为 $0$ 的 $a_1, \ldots, a_n \in \mathbb F$，使得<br>$$<br>a_1\mathbf{v}_1 + \ldots + a_m\mathbf{v}_m = \mathbf{0}<br>$$<br>$a_2, a_3, \ldots, a_n$不会全为 $0$（因为 $\mathbf{v}_1 \neq \mathbf{0}$）。设 $j$ 是 ${2, \ldots, m}$ 中使得 $a_j \neq 0$ 的最大者，那么<br>$$<br>\mathbf{v}_j = -\frac {a_1} {a_j}\mathbf{v}_1 - \ldots - \frac {a_{j - 1}} {a_j}\mathbf{v}_{j - 1}<br>$$<br>这就有 $(1)$ 成立。</p>
<p>为了证明 $(2)$，设 $\mathbf{u} \in \mathrm{span}(\mathbf{v}_1, \ldots, \mathbf{v}_n)$，则存在 $c_1, \ldots, c_n \in F$，使得<br>$$<br>\mathbf{u} = c_1\mathbf{v}_1 + \ldots + c_n\mathbf{v}_n<br>$$<br>在上面的等式中，可以用之前的等式右边来代替$ \mathbf{v}_j$。这样 $\mathbf{u} $包含于从 $(\mathbf{v}_0, \ldots, \mathbf{v}_n)$ 去掉第 $j$ 项的张成，因而 $(2)$ 成立。</p>
<h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><p> 对于一个十进制数 $a$，我们将其转换为二进制得到 $(b_m\dots b_0)_2$。然后将转换后的二进制看作是一个向量，则得到$\mathbf a = (b_m,b_{m-1},\dots,b_0)$。方便起见，我们称向量 $\mathbf a$ 的第 $i$ 位为 $b_i$。</p>
<p>向量组 $\mathbf a_1,\dots\mathbf a_n$ 可以张成一个向量集合 $\mathrm{span}(\mathbf a_1,\dots,\mathbf a_n)$，则可以得到一个线性空间 $\mathrm V = ({0,1},\mathrm{span}(\mathbf a_1,\dots,\mathbf a_n),\oplus,\cdot)$。</p>
<p>按照以下的方法得到这个线性空间的一个基 $\mathfrak B = (\mathbf a_1,\dots,\mathbf a_n)$ ：</p>
<p><strong>第 $1$ 步：</strong>如果 $\mathbf a_1 = \mathbf 0$，则从 $\mathfrak B$ 中去除 $\mathbf a_1$，否则保持 $\mathfrak B$ 不变。</p>
<p><strong>第 $j$ 步：</strong>如果 $\mathbf a_j \in \mathrm{span}(\mathbf a_1, \dots ,\mathbf a_{j - 1})$ ，则从 $\mathfrak B$ 中去掉 $\mathbf a_j$，否则保持 $\mathfrak B$ 不变。</p>
<p>经过 $n$ 步后终止程序，得到一个向量组 $\mathfrak B$。由于每一次去掉的项包含于前面诸向量的张成，到最后这个组 $\mathfrak B$ 仍然可以张成 $\mathrm V$。而且这一程序确保了 $\mathfrak B$ 中的任何向量都不包含于它前面诸向量的张成，根据线性相关性引理可知 $\mathfrak B$ 是<strong>线性无关</strong>的。于是 $\mathfrak B$ 是 $\mathrm V$ 的一个基。</p>
<p>利用高斯消元来判断向量能否被前面的向量张成，就可以写出下面的程序</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BASE 63 <span class="hljs-comment">// 当数据为long long型时，int型为31</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = MAX_BASE; j &gt;= <span class="hljs-number">0</span>; j--)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(a[i] &gt;&gt; j &amp; <span class="hljs-number">1</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(b[j])</span><br><span class="line">                    a[i] ^= b[j];</span><br><span class="line">                <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                    b[j] = a[i];</span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--)&#123;</span><br><span class="line">                        <span class="hljs-keyword">if</span> (b[k] &amp;&amp; (b[j] &gt;&gt; k &amp; <span class="hljs-number">1</span>))</span><br><span class="line">                            b[j] ^= b[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j + <span class="hljs-number">1</span>; k &lt;= MAX_BASE; k++)&#123;</span><br><span class="line">                        <span class="hljs-keyword">if</span> (b[k] &gt;&gt; j &amp; <span class="hljs-number">1</span>)</span><br><span class="line">                            b[k] ^= b[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="hljs-number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>b[]</code>数组用来记录最后得到的基 $\mathfrak B$ ；<code>a[]</code>数组为起初的每一个数字，即 $\mathbf a_1,\mathbf a_2,\dots,\mathbf a_n$。</li>
<li>虽然数组每一个位置存储的是一个<code>int</code>型数字，但实际上表示的是一个二进制向量，为了表述方便，我们称<code>b[i]</code>为数组<code>b[]</code>的第 $i$ 行。</li>
<li>在第 $i$ 步时，从高到低考虑数 $a_i$ 为 $1$ 的二进制位 $j$，如果数组<code>b[]</code>中第 $j$ 行已经存在内容了，我们就不能将$a_i$ 加到<code>b[]</code>中第 $j$ 行这个位置。而为了保证未来加进去的基向量与其他基向量<strong>线性无关</strong>，将数 $a_i$ 与 $b_i$ 进行异或计算，就可以消掉可用已经存在的基向量来表示的部分。</li>
<li>如果数组<code>b[]</code>中的第 $j$ 行不存在内容（内容为 $0$），则我们可以将（已经被前面步骤处理好的）数 $a_i$ 加入到这一行。此后为了维护对角矩阵，先用下面的行消自己，再用自己消上面的行。</li>
<li>上面代码中，<code>b[j] &gt;&gt; k &amp; 1</code>可以用来判断 $b_j$ 二进制的第 $k$ 位是否为 $1$。为什么需要<code>&amp; 1</code>？如果没有这个操作，我得到的不仅仅是第 $k$ 的信息，<code>&amp; 1</code>可以让结果只保留第 $k$ 位的信息。</li>
</ul>
<p>我们来模拟一下这个过程。设 $n = 5$，$a = {7, 1, 4, 3, 5}$。矩阵 $\mathfrak B$ 一开始长这样：<br>$$<br>\begin{bmatrix}<br>0  &amp;0 &amp;0 \\<br>0 &amp;0 &amp;0  \\<br>0 &amp;0 &amp;0<br>\end{bmatrix}<br>$$<br>我们从 $a_1$ 开始，$a_1 = 7 = (111)_2 = \mathbf a_1$，而 $\mathfrak B$ 目前为空。所以我就可以直接把他放进去了，因为$j = \mathrm{$MAX\_BASE} = 2$，所以我就把他放在了第二行（因为是上三角矩阵，所以最下面的为第 $0$ 行）。<br>$$<br>\begin{bmatrix}<br>1 &amp;1 &amp;1 \\<br>0 &amp;0 &amp;0 \\<br>0 &amp;0 &amp;0<br>\end{bmatrix}<br>$$<br>然后考虑放$a_2$，$a_2 = 1 = (001)_2 = \mathbf a_2$，在 $j = 2$ 与 $j = 1$ 时都不满足<code>a[i] &gt;&gt; j &amp; 1</code>的条件，所以不进行操作。$j = 0$ 时，第 $0$ 行没内容，所以就直接放在了第 $0$ 行上，于是矩阵就成了：<br>$$<br>\begin{bmatrix}<br>1 &amp;1 &amp;1 \\<br>0 &amp;0 &amp;0 \\<br>0 &amp;0 &amp;1<br>\end{bmatrix}<br>$$<br>然后用下面的行消自己，好的不存在下面的行。再用自己消上面的行，所以第 $2$ 行会消去最后一个 $1$，矩阵变成：<br>$$<br>\begin{bmatrix}<br>1 &amp;1 &amp;0 \\<br>0 &amp;0 &amp;0 \\<br>0 &amp;0 &amp;1<br>\end{bmatrix}<br>$$<br>接下来就轮到了 $a_3$ 了，$a_3 = 4 = (100)_2 = \mathbf a_3$，在 $j = 2$ 时符合条件，但第 $2$ 行已经有内容了，所以我们进行 $a_3 = a_3 \oplus b_2$ 的操作，于是 $a_3$ 成了 $(010)_2$ 。$j = 1$ 时有一次满足条件，所以将他放在了第 $1$ 行上，于是矩阵成了：<br>$$<br>\begin{bmatrix}<br>1 &amp;1 &amp;0 \\<br>0 &amp;1 &amp;0 \\<br>0 &amp;0 &amp;1<br>\end{bmatrix}<br>$$<br>然后用下面的行消自己，好的什么都消不了。然后用自己消上面的行，所以第 $2$ 行中间的 $1$ 被消掉了，矩阵变成了：<br>$$<br>\begin{bmatrix}<br>1 &amp;0 &amp;0 \\<br>0 &amp;1 &amp;0 \\<br>0 &amp;0 &amp;1<br>\end{bmatrix}<br>$$<br>接下来谁也进不去了，结束。</p>
<p><strong>那既然已经知道了结果会是一个上三角矩阵为啥我不直接生成一个呢？</strong>因为最终生成的 $\mathfrak B$ 很有可能不是一个满的上三角矩阵，比如这个样子的：<br>$$<br>\begin{bmatrix}<br>1 &amp;0 &amp;1&amp;0 \\<br>0 &amp;1 &amp;0 &amp;0 \\<br>0 &amp;0 &amp;0 &amp;0 \\<br>0 &amp;0 &amp;0 &amp;1<br>\end{bmatrix}<br>$$<br>这样所有被选上的 $\mathbf a_i$ 构成了一个向量空间 $\mathrm V$ 的一个基 $\mathfrak B$，同样矩阵 $b$ 的每一个非 $\mathbf 0$ 向量 $\mathbf b_i$ 组成的基也是向量空间 $\mathrm V$ 的基。我们所指的<strong>线性基</strong>，特指高斯消元解出的对角矩阵的非零行构成的向量组。如果矩阵的主对角线上第 $i$ 行的元素为 $1$，此时我们称第 $i$ 位存在于线性基中。对于存在于线性基的二进制位，有一个重要的性质：<br>$$<br>对于任意存在于线性基的二进制位\ i ，至多只有一个\ \mathbf b_j\ 满足第\ i\ 位为\ 1。<br>$$<br>因为我们已经在得到线性基的过程中，不断地使用每一个向量来对上下进行消除，所以 $\mathbf b_j$ 一定消去了别的向量第 $i$ 位上的 $1$，所以二进制位 $i$ 只存在于 $\mathbf b_j$ 上。而对于不再线性基中的二进制位 $i$，那么主对角线第 $i$ 行位以下的全部为 $0$， 而上方就可能会有若干个 $1$。</p>
<h2 id="线性基的应用"><a href="#线性基的应用" class="headerlink" title="线性基的应用"></a>线性基的应用</h2><p>线性基的题型相对比较固定，以下几类基本就是线性基了：</p>
<ul>
<li>最大异或和</li>
<li>第 $k$ 大异或和 / 这些元素的异或和是第几大</li>
<li>求所有异或值的和</li>
</ul>
<h3 id="例题-1-To-xor-or-not-to-xor"><a href="#例题-1-To-xor-or-not-to-xor" class="headerlink" title="例题$(1)$ To xor or not to xor"></a>例题$(1)$ To xor or not to xor</h3><p>题目连接：<a href="https://codeforces.com/problemsets/acmsguru/problem/99999/275" target="_blank" rel="noopener">https://codeforces.com/problemsets/acmsguru/problem/99999/275</a></p>
<blockquote>
<h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>The sequence of non-negative integers $A_1$, $A_2$, …, $A_n$ is given. You are to find some subsequence $Ai_1$, $Ai_2$, …, $Ai_k$ $(1 \leq i_1 &lt; i_2 &lt; … &lt; i_k \leq  N)$ such, that $Ai_1 \oplus Ai_2 \oplus \dots  \oplus Ai_k$ has a maximum value.</p>
<h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>The first line of the input file contains the integer number $N$ $(1 \leq N \leq 100)$. The second line contains the sequence $A_1, A_2, \dots , A_n (0 \leq Ai \leq 10^{18})$. </p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>Write to the output file a single integer number – the maximum possible value of  $Ai_1 \oplus Ai_2 \oplus \dots  \oplus Ai_k$ . </p>
<h4 id="Sample-test-s"><a href="#Sample-test-s" class="headerlink" title="Sample test(s)"></a>Sample test(s)</h4><h5 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">11 9 5</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h5 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure>
</blockquote>
<p>很单纯的求最大异或和。根据以上的内容，我们可以求出这个向量空间的一组线性基 $\mathfrak B$，则<strong>最大的异或和就是将线性基中所有的向量异或起来得到的向量所对应的数</strong>。证明如下：</p>
<p>最高的二进制位只存在于数值最大的基向量上，所以最大的基向量肯定要被选。运用归纳法，假设前 $i$ 大的都需要选，考虑第 $i + 1$ 大的向量选不选。显然第 $i + 1$ 大的基向量能对异或和贡献它的最高的二进制位 $j$，因为二进制位 $j$ 在之前的异或和中必然为零（因为二进制位 $j$ 只存在于第 $i + 1$ 大的基向量中）。如果不选，之后的所有数对答案的贡献都只能在小于这个二进制位的地方做贡献，总是比选 $i + 1$ 得到的答案小，所以这个数必须选。</p>
<p>AC代码：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BASE 63</span></span><br><span class="line"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">101</span>];</span><br><span class="line"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b[MAX_BASE];</span><br><span class="line"><span class="hljs-keyword">int</span> n;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = MAX_BASE; j &gt;= <span class="hljs-number">0</span>; j--)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(a[i] &gt;&gt; j &amp; <span class="hljs-number">1</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(b[j])</span><br><span class="line">                    a[i] ^= b[j];</span><br><span class="line">                <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                    b[j] = a[i];</span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j - <span class="hljs-number">1</span>; k &gt;= <span class="hljs-number">0</span>; k--)&#123;</span><br><span class="line">                        <span class="hljs-keyword">if</span> (b[k] &amp;&amp; (b[j] &gt;&gt; k &amp; <span class="hljs-number">1</span>))</span><br><span class="line">                            b[j] ^= b[k];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = j + <span class="hljs-number">1</span>; k &lt;= MAX_BASE; k++)&#123;</span><br><span class="line">                        <span class="hljs-keyword">if</span> (b[k] &gt;&gt; j &amp; <span class="hljs-number">1</span>)</span><br><span class="line">                            b[k] ^= b[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span> ,&amp;n);</span><br><span class="line">    <span class="hljs-built_in">memset</span>(b, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(b));</span><br><span class="line">    <span class="hljs-built_in">memset</span>(choice, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(choice));</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cal();</span><br><span class="line">    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= MAX_BASE; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(b[i])&#123;</span><br><span class="line">            ans ^= b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/07/27/尺取法/" class="image is-7by1">
            <img class="thumbnail" src="/img/尺取法/banner.jpeg" alt="算法学习：尺取法">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-27T07:10:40.000Z">2019-07-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    4 分钟 读完 (大约 560 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/07/27/尺取法/">算法学习：尺取法</a>
            
        </h1>
        <div class="content">
            <p>假设给你一个数组与一个整数，要求你的到这个数组中的一个子区间使其的区间和等于这个整数，你会怎么做呢。可能首先想到的就是开一个双重循环，然后每一次都求一次和，然后和给定的数进行比较：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> sum;</span><br><span class="line"><span class="hljs-keyword">int</span> ansi, ansj;</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">        sum = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i; k &lt;= j; k++)&#123;</span><br><span class="line">            sum += ls[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(sum == x)&#123;</span><br><span class="line">            ansi = i; ansj = j;</span><br><span class="line">            <span class="hljs-keyword">goto</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans:</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d\n"</span>, ansi, ansj);</span><br></pre></td></tr></table></figure>

<p>这样的话，复杂度就会到达 $O(n^2)$。</p>
<p>尺取法的算法思想来源于以上那个算法，区别在于不再对前后指针进行疯狂枚举，也不再需要每次都进行一次求和。我们设置两个指针，起初都指向开头。然后如果区间的元素和小于给定的数，则将右指针右移。如果大于指定的数，则将区间的左指针右移。相同就出结果了。这样的话每次求和只需要加上或减去那个唯一一个有区别的元素。复杂度会降低到 $O(n)$。</p>
<p>如下习题（POJ 3016）：</p>
<blockquote>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>A sequence  of $N$ positive integers $(10 &lt; N &lt; 100000)$, each of them less than  or equal $10000$, and a positive integer $S(S &lt; 100000000)$ are given.  Write a program to find the minimal length of the subsequence of  consecutive elements of the sequence, the sum of which is greater than  or equal to $S$.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The  first line is the number of test cases. For each test case the program  has to read the numbers $N$ and $S$, separated by an interval, from the  first line. The numbers of the sequence are given in the second line of  the test case, separated by intervals. The input will finish with the  end of file.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each the case the program has to print the result on separate line of the output file. if no answer, print $0$.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">10 15</span><br><span class="line">5 1 3 5 10 7 4 9 2 8</span><br><span class="line">5 11</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
</blockquote>
<p>AC代码：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> lis[<span class="hljs-number">100005</span>];</span><br><span class="line"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="hljs-keyword">return</span> b;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> T;</span><br><span class="line">    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="hljs-keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> N, S;</span><br><span class="line">        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;N, &amp;S);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-keyword">size_t</span>)N; i++) &#123;</span><br><span class="line">            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;lis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;</span><br><span class="line">        sum = lis[<span class="hljs-number">0</span>];</span><br><span class="line">        <span class="hljs-keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; right &lt; N)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(sum &lt; S)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                sum += lis[right];</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt;= S)&#123;</span><br><span class="line">                ans = min(ans, right - left + <span class="hljs-number">1</span>);</span><br><span class="line">                sum -= lis[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&gt;</span><br><span class="line">        <span class="hljs-keyword">if</span>(ans != INT_MAX)</span><br><span class="line">            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"0\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/07/26/倍增/" class="image is-7by1">
            <img class="thumbnail" src="/img/倍增思想/banner.jpeg" alt="算法学习：倍增思想">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-26T02:33:52.000Z">2019-07-26</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分钟 读完 (大约 1733 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/07/26/倍增/">算法学习：倍增思想</a>
            
        </h1>
        <div class="content">
            <p>个人认为来源于二进制的思想。</p>
<p><img src="/img/%E5%80%8D%E5%A2%9E%E6%80%9D%E6%83%B3/1352815365_3021.jpg" alt="img"></p>
<p>对于如图式的一系列区域。</p>
<p>以往的记录方式，都是从A出发，走一步到了A右面一格，走两步到了A右面两格位置，……，走11步，走到了B位置。这样记录的话，每个节点都需要记录 $n - i$ 条内容，全部也就是需要 $\frac{n(n-1)}{2}$条，也就是 $O(n^2)$ 的空间复杂度。而由于每个数都可以写为2进制，那么每个点我只需要记录走一步、走两步、走四步、走八步……的位置，比如从A点，我可以走 $1+2+8=11$ 步到达B，也就是读取A走1步后在读取目前这个格子走两步再读取目前这个格子走八步的位置就可以到达B点。</p>
<p>而对于每一个点，走4步的位置就相当于走两步后的位置再走两步，走八步的位置就相当于走两步的位置再走两步再走两步……以此类推。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><blockquote>
<p>位运算符为二进制运算符，所以是将参与运算的数据转换为二进制后进行运算。按右对齐，左补符号位运算。</p>
</blockquote>
<ul>
<li><code>&gt;&gt;</code>：右移运算符，右移 $i$ 位相当于将该数乘以了 $2^i$。</li>
<li><code>&lt;&lt;</code>：左移运算符，左移 $i$ 位相当于将该数除以了 $2^i$。</li>
<li><code>&amp;</code>：按位与运算，如 $5 &amp; 3$ 相当于即为$(0101)_2 &amp; (0011)_2 = (0001)_2$，所以结果为$1$。</li>
<li><code>|</code>：按位或运算 ，如 $5 \ | \ 3$ 相当于 $(0101)_2\ |\ (0011)_2 = (0111)_2$，所以结果为$7$。</li>
<li><code>~</code>：按位取反。</li>
<li><code>^</code>：异或运算符，如 $5 \ \text{^} \ 3$ 相当于 $(0101)_2\ \text{^} \ (0011)_2 = (0110)_2$，所以结果为$6$。<ul>
<li>异或交换律：$a\otimes b = b\otimes a$</li>
<li>异或结合律：$(a\otimes b)\otimes c= a\otimes(b\otimes c)$</li>
<li>异或自反性：$a\otimes b\otimes b=a\otimes 0=a$</li>
<li>对于任何数都有：$x\otimes x =0$、$x\otimes 0=x$</li>
</ul>
</li>
<li><code>&amp;=</code>、<code>|=</code>、<code>&gt;&gt;=</code>、<code>&lt;&lt;=</code>、<code>^=</code>：位运算的复合赋值运算符</li>
</ul>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">T</span> <span class="hljs-title">quick_power</span>(<span class="hljs-title">T</span> <span class="hljs-title">x</span>,<span class="hljs-title">T</span> <span class="hljs-title">y</span>)&#123;</span>  <span class="hljs-comment">// 求x^y</span></span><br><span class="line">    <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = y; i; i &gt;&gt;= <span class="hljs-number">1</span>, x = x * x)</span><br><span class="line">        <span class="hljs-keyword">if</span>(i &amp; <span class="hljs-number">1</span>) p = p * x;</span><br><span class="line">    <span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>i &gt;&gt;= 1</code>：即<code>i /= 2</code>，用于不断地向右取幂次数的二进制位。</p>
</li>
<li><p><code>i &amp; 1</code>：用以判断对应这一二进制是否需要进行$\times x^{2^{cnt}}$（$cnt$ 为要进行的幂次方数，由 <code>x = x * x</code> 语句决定）处理。</p>
</li>
<li><p>原理即为对于任意的被幂次数都可以写为2进制形式。如$13$可写为$1101$，那么$5^{13} = 5^{2^3\times1+2^2\times1+2^1\times0+2^0\times1}=5^{2^3} \times 5^{2^2}\times 5^{2^0}$</p>
</li>
<li><p>设最开始<code>x</code>值为 $x$，第<code>i</code>次循环<code>x</code>值为 $x_i$，则可以得到 $x_i = x^{2^i}$。</p>
</li>
</ul>
<h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p>ST表是一种离线查询表，用以查找特定区间内的最大（最小）值。预处理的时间复杂度为$\text O(n\log n)$，查找时间复杂度为$\text O(1)$，优于线段树（线段树的预处理与查找的复杂度均为$\text O(n\log n)$）。</p>
<ul>
<li><code>st[x][y]</code> 用以查询区间$[x,x+2^y-1]$内数的最大（最小）值，也就是从 $x$ 开始的 $2^y$ 个数的最大（最小）值。</li>
<li><code>st[x][y]</code> 是<code>a[x]</code>本身。</li>
</ul>
<h3 id="预处理（实例中为查找最小值的ST表）"><a href="#预处理（实例中为查找最小值的ST表）" class="headerlink" title="预处理（实例中为查找最小值的ST表）"></a>预处理（实例中为查找最小值的ST表）</h3><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> a[<span class="hljs-number">1010</span>];<span class="hljs-comment">//原始输入数组</span></span><br><span class="line"><span class="hljs-keyword">int</span> st[<span class="hljs-number">1010</span>][<span class="hljs-number">20</span>];<span class="hljs-comment">//st表</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)</span><br><span class="line">        st[i][<span class="hljs-number">0</span>] = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt; n; i++)</span><br><span class="line">            st[i][j] = min(st[i][j - <span class="hljs-number">1</span>],st[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>1 &lt;&lt; j</code> 相当于求出$2^j$的值</li>
<li>$\text{st}[x][y] = max/min(\text{st}[i,j-1],\text{st}[i+2^{j-1},j-1])$：将$[x,x+2^y-1]$（指序号大小，下同）分为$[x,x+2^{y-1}-1]$与$[x+2^{y-1},x+2^y-1]$两部分</li>
<li>因为<code>j</code>是从小到大遍历的，所以在得到<code>st[i][j]</code>的值之前，一定会得到<code>st[i + (1 &lt;&lt; (j-1))][j - 1]</code>的值</li>
</ul>
<h3 id="查找（实例为查找最小值）"><a href="#查找（实例为查找最小值）" class="headerlink" title="查找（实例为查找最小值）"></a>查找（实例为查找最小值）</h3><p>查找区间$[l,r]$内的最小值：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> k = (<span class="hljs-keyword">int</span>)(<span class="hljs-built_in">log</span>((<span class="hljs-keyword">double</span>)(r - l + <span class="hljs-number">1</span>)) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2.0</span>));</span><br><span class="line">    <span class="hljs-keyword">return</span> min(st[l][k],st[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>有定理： $2^{\log_2 a}&gt;\frac{a}{2}$ 成立。如果设 $t = \log_2{len}$，其中 $len$ 为从 $l$ 到 $r$ 的长度（$len = r-l+1$），则有$2^{\log_2len} &gt; \frac{len}{2} \Rightarrow 2^t &gt; \frac{len}{2}$ 成立，所以 $l+2^t$ 跨过了区间的中间位置，那么我们可以得到 $l$ 到 $r$ 的最小值是 $l$向前 $2^k$ 长度区间与 $r$ 向前 $2^k$ 长度区间的最小值的最小值。所以区间 $[l,r]$ 内的最小值为<code>min(st[l][k], st[r - (1 &lt;&lt; k) + 1][k])</code>。</li>
</ul>
<h2 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h2><ul>
<li><em>LCA</em>：最近公共祖先。</li>
<li>从 <em>LCA</em> 的定义可以得到：两点的 <em>LCA</em> 一定是两个点的祖先中深度最大的。那么也就是说<strong>两个点如果深度相同的话</strong>，他们沿着树向上走<code>x</code>步就可以同时到达 <em>LCA</em> 。<ul>
<li>如果深度不同，则深度较大的向上跳到深度相同的地方。</li>
<li>如果深度相同，则一同向上跳到找到 <em>LCA</em>。</li>
</ul>
</li>
</ul>
<h3 id="倍增法求LCA"><a href="#倍增法求LCA" class="headerlink" title="倍增法求LCA"></a>倍增法求LCA</h3><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(depth[a] &lt; depth[b])</span><br><span class="line">        swap(a, b);</span><br><span class="line">    <span class="hljs-keyword">int</span> c = depth[a] - depth[b];</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>;i--)</span><br><span class="line">        <span class="hljs-keyword">if</span>(c &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) a = fa[a][i];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// if(u == v) return u;</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">20</span>;i &gt;= <span class="hljs-number">0</span>;i--)</span><br><span class="line">        <span class="hljs-keyword">if</span>(fa[a][i]!=fa[b][i])</span><br><span class="line">            a = fa[a][i], b = fa[b][i];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> fa[a][<span class="hljs-number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中数组<code>fa[a][x]</code>表示的是对于节点<code>a</code>，向上跳$2^x$次后的父节点。这体现了倍增二分的思想。</li>
<li><code>i</code>从大到小遍历，遍历到了父节点不同就将<code>a</code>,<code>b</code>转移到这个不同的节点，然后继续向上遍历。通过二分法来降低算法复杂度。</li>
</ul>
<h3 id="ST表求LCA"><a href="#ST表求LCA" class="headerlink" title="ST表求LCA"></a>ST表求LCA</h3><p><img src="/img/%E5%80%8D%E5%A2%9E%E6%80%9D%E6%83%B3/1563251878821.png" alt="1563251878821"></p>
<p>如上图所示的树，使用DFS遍历$^*$，并对每个点进行编号，得到一下序列：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">D</th>
<th align="center">B</th>
<th align="center">E</th>
<th align="center">F</th>
<th align="center">E</th>
<th align="center">G</th>
<th align="center">E</th>
<th align="center">B</th>
<th align="center">A</th>
<th align="center">C</th>
<th align="center">A</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>$^*$ 不同于一般的DFS遍历，这里的DFS遍历需要记录回溯走过的顶点信息。</p>
<p>则可以得到以下性质：两个点<strong>首次</strong>出现位置中间这一段中深度最小（也就是值最小）的即为两点的LCA。</p>
<p>所以我们就可以把求LCA转换为求一段序列中的最小值 → 转换为使用ST表求一段的最小值。</p>
<p>所使用的DFS算法如下：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> q[<span class="hljs-number">1000000</span>];</span><br><span class="line">top = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> Fa)</span></span>&#123;</span><br><span class="line">    q[++top] = u, sta[u] = top;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">30</span>;i++)</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u];i;i = e[i].next)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> to = e[i].to;</span><br><span class="line">        <span class="hljs-keyword">if</span>(to == Fa)</span><br><span class="line">            <span class="hljs-keyword">continue</span>;</span><br><span class="line">        fa[to][<span class="hljs-number">0</span>] = u;</span><br><span class="line">        dfs(to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    q[++top] = u,end[u] = top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求LCA的具体算法如下：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ans = INT_MAX;</span><br><span class="line">    begin = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (q[i] == a || q[i] == b)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(!begin)</span><br><span class="line">                begin = <span class="hljs-number">1</span>;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (begin)</span><br><span class="line">           ans = min(ans, q[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/07/22/AC自动机/" class="image is-7by1">
            <img class="thumbnail" src="/img/AC自动机/banner.jpeg" alt="算法学习：字典树、KMP与AC自动机">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-22T08:13:15.000Z">2019-07-22</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    26 分钟 读完 (大约 3898 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/07/22/AC自动机/">算法学习：字典树、KMP与AC自动机</a>
            
        </h1>
        <div class="content">
            <h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><blockquote>
<p>学习自博客：<a href="https://blog.csdn.net/qq_42815188/article/details/88677836" target="_blank" rel="noopener">https://blog.csdn.net/qq_42815188/article/details/88677836</a></p>
</blockquote>
<p><strong>字典树</strong>（又称为单词查找树，Tire 树）是一种树形结构。它与字典相似，当要查找的一个单词是否在字典树中，首先看单词的第一个字母是否在字典树的第一层。如果不在，说明字典树中没有该单词；如果在，就在该单词的子节点中找是否有单词的第二个字母，如果没有，则说明没有此单词，有的话就继续查找，以此类推。</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563343331926.png" alt="字典树"></p>
<p>字典树有以下的基本性质：</p>
<ul>
<li>字典树使用边表示字符；（也可以理解为每个节点上保存字符，因为这个边的信息是使用<code>j</code>节点来标识的）</li>
<li>有相同的前缀的单词共用前缀节点；</li>
<li>根结点不包含有字符；</li>
<li>每个单词结束的时候都用一个特殊字符表示，如图中使用的是一个 $ \$ $ 符号；（或者使用数字表示存在该字符串的个数）</li>
<li>从根结点道到一个 $ \$ $ 所经过的所有边的字母就是一个字符串。</li>
</ul>
<p>字典树常用于<strong>统计、排序和保存大量的字符串</strong>（不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p>
<p>优点：利用字符串的公众前缀来节约存储空间，最大限度地减少无用字符串的比较。</p>
<h2 id="构建字典树"><a href="#构建字典树" class="headerlink" title="构建字典树"></a>构建字典树</h2><h3 id="编号方案"><a href="#编号方案" class="headerlink" title="编号方案"></a>编号方案</h3><p>引入数组<code>tire[][]</code>。<code>tire[i][j] = k</code>表示：<strong><code>tire</code>树中编号为<code>i</code>的节点的边上为字母<code>(char)( &#39;a&#39; + j )</code>的儿子为编号为<code>j</code>的节点</strong>（这里不用于一般的树的储存方式）。而这个节点应存储的信息（如这个单词出现了多少次）则<strong>单独开一个以编号为下标的数组</strong>来记录。</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563346974092.png" alt="数组编号信息"></p>
<p>以此种方式标记好的字典树将如下图所示：（图中的数字指的是这条边结尾处的节点的编号，其中根结点编号为 $0$）。</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563347129754.png" alt="建树"></p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>当有新的需要插入的词语（字符串）出现时，我们就依次对比每一个字母在对应层中是否已经出现来判断新进入的词语是否与已经存在的词相同或语有相同的前缀。当出现差异时，我们就标记激活这个节点（标记这个节点为单词词尾节点并将其值（指另一个存储该节点信息的值）加一）。相同词语则直接使词尾节点的值（指另一个存储该节点信息的值）递增。具体操作如下代码：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 实例为字符串中只有'a'~'b'26个字母的字典树</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIGMA_SIZE 26</span></span><br><span class="line"><span class="hljs-comment">// MAXN_NODE根据题意进行赋值</span></span><br><span class="line"><span class="hljs-keyword">int</span> tire[MAXN_NODE][SIGMA_SIZE] = &#123;<span class="hljs-number">0</span>&#125;; </span><br><span class="line"><span class="hljs-keyword">int</span> tag[MAXN_NODE] = &#123;<span class="hljs-number">0</span>&#125;;                      <span class="hljs-comment">// 标记编号为i的节点是否为单词节点</span></span><br><span class="line"><span class="hljs-keyword">int</span> cnt[MAXN_NODE] = &#123;<span class="hljs-number">0</span>&#125;;                      <span class="hljs-comment">// 记录编号为i的单词节点所对应的单词出现次数</span></span><br><span class="line"><span class="hljs-keyword">int</span> node = <span class="hljs-number">0</span>;                                  <span class="hljs-comment">// Trie树的节点个数</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;                               <span class="hljs-comment">// 用以记录目前遍历到的节点编号</span></span><br><span class="line">    <span class="hljs-keyword">int</span> len = str.length();</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(!tire[now][str[i] - <span class="hljs-string">'a'</span>])&#123;          <span class="hljs-comment">// 如果这个节点未曾有子节点（前缀出现偏差）</span></span><br><span class="line">            tire[now][str[i] - <span class="hljs-string">'a'</span>] = ++node;</span><br><span class="line">        &#125;</span><br><span class="line">        now = ch[now][str[i] - <span class="hljs-string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tag[now] = <span class="hljs-literal">true</span>;</span><br><span class="line">    cnt[now] ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>只要建树搞得好，这就莫的问题。</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 如果找到则返回词的个数，如果没有找到或无该词则返回-1</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> len = str.length();</span><br><span class="line">    <span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> c = str[i] - <span class="hljs-string">'a'</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(tire[now][c] == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 没有子节点了，也就是这个单词不存在实锤</span></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = trir[now][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(tag[now])</span><br><span class="line">        <span class="hljs-keyword">return</span> cnt[now];</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><blockquote>
<p>学习自博客：<a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></p>
</blockquote>
<p>Knuth-Morris-Pratt 字符串查找算法，简称 KMP 算法，常用在于一个文本串S内查找一个模式串P的出现位置，这个算法由<em>Donald Knuth</em>、<em>Vaughan Pratt</em>、<em>James H. Morris</em>三人联合发表，故取这三个人的姓氏命名此算法。</p>
<p>传统的模式串匹配使用的是纯暴力匹配算法。</p>
<h2 id="纯暴力匹配"><a href="#纯暴力匹配" class="headerlink" title="纯暴力匹配"></a>纯暴力匹配</h2><ul>
<li>如果当前字符匹配成功（<code>S[i] == P[j]</code>），则<code>i++</code>、<code>j++</code>，继续匹配下一个字符；</li>
<li>如果没有匹配成果（<code>S[i] != P[j]</code>），则令<code>i = i - (j - i)</code>（回溯到开始匹配的字符的下一个字符）、<code>j = 0</code>，重新匹配模式串。</li>
</ul>
<p>如以下的图解（假设文本串<code>S = &quot;BBC ABCDAB ABCDABCDABDE&quot;</code>，模式串<code>P = &quot;ABCDABD&quot;</code>）：</p>
<ul>
<li><p>首先从第0位开始匹配：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140723224710203" alt="匹配第0位"></p>
<p>发现匹配不成功，则匹配串右移。  </p>
</li>
<li><p>匹配文本串的第1位：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140726213551553" alt="匹配第1位"></p>
<p>发现依旧不匹配，继续将匹配串右移。</p>
</li>
<li><p>直到出现了一次匹配（匹配串移动到了第4位）：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140726213602848" alt="第1位匹配成功"></p>
<p>发现匹配成功，则<code>i++</code>、<code>j++</code>。对下一位进行匹配。</p>
</li>
<li><p>将文本串的第5位与匹配串的第1位匹配：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140726213343578" alt="第2位匹配成功"></p>
<p>发现匹配成功，继续<code>i++</code>、<code>j++</code>。对下一位匹配，直到出现不能匹配的项。</p>
</li>
<li><p>再次出现不能匹配的项：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140726213353687" alt="出现失配"></p>
<p>发现匹配不成功，则匹配串右移，重新从匹配串的第一位开始进行匹配。</p>
</li>
<li><p>じゃ、もう一度！</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140726213631208" alt="重新匹配"></p>
</li>
</ul>
<p>从示例可以看出，这种匹配模式下，每次出现错误的匹配都需要回溯到词头再进行匹配，十分的低效，算法复杂度也到了$O(m\cdot n)$。如果我们在进行匹配的时候，能基本做到不进行回溯而只移动模式串的话，算法复杂度将极大地提升。</p>
<h3 id="KMP算法匹配字符串"><a href="#KMP算法匹配字符串" class="headerlink" title="KMP算法匹配字符串"></a>KMP算法匹配字符串</h3><p>让我们回到起点重新进行模式串匹配：</p>
<ul>
<li><p>首先匹配文本串的第0位：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140723224710203" alt="KMP匹配第0位"></p>
<p>发现匹配不成功，则匹配串右移。</p>
</li>
<li><p>匹配文本串的第1位：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140726213551553" alt="KMP匹配第1位"></p>
<p>发现依旧不匹配，继续将匹配串右移。</p>
</li>
<li><p>直到出现了一次匹配（匹配串移动到了第4位）：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140726213602848" alt="KMP第1位匹配成功"></p>
<p>发现匹配成功，则<code>i++</code>、<code>j++</code>。对下一位进行匹配。</p>
</li>
<li><p>将文本串的第5位与匹配串的第1位匹配：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140726213343578" alt="KMP第2位匹配成功"></p>
<p>发现匹配成功，继续<code>i++</code>、<code>j++</code>。对下一位匹配，直到出现不能匹配的项。</p>
</li>
<li><p>再次出现不能匹配的项：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140726213353687" alt="KMP失配"></p>
<p>发现匹配不成功，则匹配串右移，重新从匹配串的第一位开始进行匹配。</p>
</li>
</ul>
<p>这时我们考虑，真的要回溯到文本串的第5位然后重新开始与模式串的第一位进行比较么？我们可以发现我们已经匹配了的部分中有一段字符串<code>&quot;AB&quot;</code>，而模式串的前缀中也有<code>&quot;AB&quot;</code>。也就是说，<strong>其实我们可以认为已经将模式串的前两位匹配成功了</strong>，我们只需要继续匹配模式串的第2位（从0开始编号）就可以了。</p>
<ul>
<li><p>不进行回溯而将模式串右移一定的位：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140721223539765" alt="KMP回溯"></p>
<p>发现匹配错误，将模式串继续移位。</p>
</li>
<li><p>移位将字符串的第10位与模式串第0位进行匹配：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140721223823548" alt="KMP回溯"></p>
</li>
<li><p>发现匹配错误，移位对字符串的下一位进行匹配。</p>
</li>
<li><p>移位将字符串第11位与模式串第0位进行匹配：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563430728158.png" alt="KMP再次回配"></p>
<p>发现匹配成功。则<code>i++</code>、<code>j++</code>，进行下一位匹配。以此类推，直到再次发生不能匹配。</p>
</li>
<li><p>直到再一次发生匹配失败：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140721223558140" alt="KMP失配"></p>
<p>情况与上一次相似，都是出现在了<code>&#39;D&#39;</code>位，所以模式串向右移动。</p>
</li>
<li><p>模式串向右移动四位：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563431095901.png" alt="KMP回溯&amp;再再回配"></p>
<p>发现匹配成功，则不断的<code>i++</code>、<code>j++</code>。</p>
</li>
<li><p>匹配完成：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/20140721223611515" alt="KMP最终匹配成功"></p>
</li>
</ul>
<p>这种匹配方式下，字符串完全不需要进行回溯，只需要将模式串进行一定量的右移就可以得到最终结果。这是一种高效的模式串匹配方法。算法的时间复杂度仅为 $O(m + n)$。</p>
<p>那么这个算法的重点就是在于：模式串应该如何的右移，也就是当发生匹配失败时，<strong>我应该去匹配模式串的哪一位</strong>？所以我们引进了<code>next[]</code>数组。</p>
<p>从我们过程的分析中可以发现，我们判断需要将模式串向右移动几位是依据我们的模式串的开头部分与结尾部分中是否有重复出现的一部分，如果存在，我们就可以移动模式串使着相同的部分重合，从而节省了前面一段部分的匹配。所以我们要找出这一位以前（包括这一位）前缀与后缀的数量的这个子串中出现的最长的具有相同元素的前缀与后缀。我们可以得到如下表格：</p>
<table>
<thead>
<tr>
<th align="center">模式串的各个子串</th>
<th align="center">前缀</th>
<th align="center">后缀</th>
<th align="center">最大公共元素长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>A</code></td>
<td align="center">空</td>
<td align="center">空</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>AB</code></td>
<td align="center"><code>A</code></td>
<td align="center"><code>B</code></td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>ABC</code></td>
<td align="center"><code>A</code>, <code>AB</code></td>
<td align="center"><code>C</code>, <code>BC</code></td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>ABCD</code></td>
<td align="center"><code>A</code>, <code>AB</code>, <code>ABC</code></td>
<td align="center"><code>D</code>, <code>CD</code>, <code>BCD</code></td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>ABCDA</code></td>
<td align="center"><code>A</code>, <code>AB</code>, <code>ABC</code>, <code>ABCD</code></td>
<td align="center"><code>A</code>, <code>DA</code>, <code>CDA</code>, <code>BCDA</code></td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>ABCDAB</code></td>
<td align="center"><code>A</code>, <code>AB</code>, <code>ABC</code>, <code>ABCD</code>, <code>ABCDA</code></td>
<td align="center"><code>B</code>, <code>AB</code>, <code>DAB</code>, <code>CDAB</code>, <code>BCDAB</code></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"><code>ABCDABD</code></td>
<td align="center"><code>A</code>, <code>AB</code>, <code>ABC</code>, <code>ABCD</code>, <code>ABCDA</code>, <code>ABCDAB</code></td>
<td align="center"><code>D</code>, <code>BD</code>, <code>ABD</code>, <code>DABD</code>, <code>CDABD</code>, <code>BCDABD</code></td>
<td align="center">0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center"><code>A</code></th>
<th align="center"><code>B</code></th>
<th align="center"><code>C</code></th>
<th align="center"><code>D</code></th>
<th align="center"><code>A</code>$_1$</th>
<th align="center"><code>B</code>$_2$</th>
<th align="center"><code>D</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">最大前缀后缀公共元素长度</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>而<code>nect[]</code>数组的作用是，重复到拥有相同前缀的位置。所以我这一位要回到哪里要看的是这一位之前的字符串中最长长度的拥有的相同的前后缀的长度为多少。而对于第一位，他之前没有字符串，所以我需要做的是将字符串右移一位然后进行重新匹配，所以<code>next[0]</code>的值应为 $-1$ 。所以<code>next[]</code>数组的值即为将最大前缀后缀公共元素长度表的内容全体后移一位然后将第0位赋值成 $ -1$ 即可！示例的<code>next[]</code>数组如下：</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center"><code>A</code></th>
<th align="center"><code>B</code></th>
<th align="center"><code>C</code></th>
<th align="center"><code>D</code></th>
<th align="center"><code>A</code>$_1$</th>
<th align="center"><code>B</code>$_1$</th>
<th align="center"><code>D</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>next[]</code>对应位的值</td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>而在求模式串的<code>next[]</code>数组的过程中，我需要找到模式串子串的前后缀，即比对模式串子串与模式串是否有相同部分的内容，同样可以使用KMP算法，所以我们在求后面几位的<code>next[]</code>时完全可以用到前面几位的<code>next[]</code>的值。</p>
<p>求得<code>next[]</code>数组的代码如下：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(<span class="hljs-built_in">string</span> p,<span class="hljs-keyword">int</span> next[])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> p_len = p.length();</span><br><span class="line">    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> k = <span class="hljs-number">-1</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 标记目前在计算第几位的next值</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (j &lt; p_len - <span class="hljs-number">1</span>)&#123;</span><br><span class="line">        <span class="hljs-comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">-1</span> || p[j] == p[k]) &#123; <span class="hljs-comment">// 初始状态或者需要右移或者匹配成功</span></span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            k = next[k]; <span class="hljs-comment">// 匹配失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用KMP算法匹配字符串的算法如下：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMPSearch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str, <span class="hljs-built_in">string</span> p)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> str_len = str.length();</span><br><span class="line">    <span class="hljs-keyword">int</span> p_len = p.length();</span><br><span class="line">    <span class="hljs-keyword">while</span> (i &lt; str_len &amp;&amp; j &lt; p_len)&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j])&#123; <span class="hljs-comment">// 如果需要后移或者匹配成功</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果匹配失败</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(j == p_len) <span class="hljs-comment">// 匹配成功</span></span><br><span class="line">        <span class="hljs-keyword">return</span> i - j;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h1><blockquote>
<p>学习自博客：<a href="https://blog.csdn.net/bestsort/article/details/82947639" target="_blank" rel="noopener">https://blog.csdn.net/bestsort/article/details/82947639</a></p>
</blockquote>
<p>AC自动机是以字典树作为搜索数据结构，利用KMP原理减少回溯的操作，以实现多模式串匹配。算法复杂度优化到了 $O(n)$。</p>
<p>AC自动机就是在字典树的基础上，增加上一个<code>fail</code>指针，如果当前点处匹配失败的话，<strong>就将指针转移到<code>fail</code>指针所指的位置</strong>，来减少没有必要的回溯。（类似KMP中的<code>next[]</code>的作用）</p>
<p>如我现在有待匹配的串，为<code>&quot;shershisher&quot;</code>。我现在有模式串<code>&quot;hers&quot;</code>、<code>&quot;hrs&quot;</code>、<code>&quot;she&quot;</code>，形成如图所示的字典树：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563438486510.png" alt="形成字典树"></p>
<p><code>fail</code>指针的作用就是在我出现匹配失败的时候，我能立刻转移到相近的能继续匹配下去的串而不需要重新再来。所以我们需要找出在不同模式串中前缀匹配的部分。<code>fail</code>指针的构建都是用BFS来实现的，基本的操作就是指向节点的父节点<code>fail</code>指针所指向的节点的子节点中与其相同的节点，如果没有，则指向它父亲节点的<code>fail</code>指针指向的节点。以如图所示的字典树，我对他进行<code>fail</code>指针构建：</p>
<ul>
<li><p>第一层遍历，每个串的首字母肯定是指向根节点：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563438931192.png" alt="第一层遍历"></p>
</li>
<li><p>第二层遍历，我们瞄准最左面的子树的第一个节点（被<code>e</code>指向的<font color="green">绿色</font>节点）：</p>
<p>应指向他的父节点（<code>h</code>指向的<font color="#F18C55">橙色</font>节点）的<code>fail</code>指针指向的节点（<font color="#66ccff">蓝色</font>的根结点）的子节点中指向边为<code>e</code>的节点，不存在，所以指向他父节点的<code>fail</code>指针指向的节点（根结点）</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563439549760.png" alt="第二层第一节点"></p>
</li>
<li><p>第二层的第二个节点，相同。接下来看第三个节点（被<code>h</code>指向的<font color="green">绿色</font>节点）：</p>
<p>应指向他的父节点（<code>s</code>指向的<font color="#F18C55">橙色</font>节点）的<code>fail</code>指针指向的节点（<font color="#66ccff">蓝色</font>的根结点）的子节点中指向边为<code>h</code>的节点（<code>h</code>指向的<font color="#F18C55">橙色</font>节点）。所以得到如下图：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563439906059.png" alt="第二层二三节点"></p>
</li>
<li><p>依次如此作图，最终得到如下图（有点乱）：</p>
<p><img src="/img/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/1563440084731.png" alt="AC自动机"></p>
</li>
</ul>
<p>在我进行字符串<code>&quot;shershisher&quot;</code>匹配时，首先匹配<code>&quot;she&quot;</code>成功，<code>ans++</code>。<code>e</code>之后没有字符继续匹配，所以指向<code>fail</code>指针指向的另一个<code>e</code>即开始匹配<code>&quot;hers&quot;</code>，匹配成功，<code>ans++</code>。后<code>s</code>指向最右侧树的<code>s</code>，开始匹配<code>&quot;she&quot;</code>，匹配到<code>h</code>后失配，所以指向<code>fail</code>开始匹配<code>&quot;hers&quot;</code>，到<code>s</code>匹配失败。所以最终结果为 $2$。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/07/19/搜索/" class="image is-7by1">
            <img class="thumbnail" src="/img/搜索/banner.jpeg" alt="算法学习：搜索">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-19T08:24:53.000Z">2019-07-19</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    18 分钟 读完 (大约 2694 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/07/19/搜索/">算法学习：搜索</a>
            
        </h1>
        <div class="content">
            <h1 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h1><p>DFS是一种使用栈结构的搜索方式，一般使用递归实现（因为递归就是在压栈嘛）。一般用于判断是否图是否连通或找到图的拓扑序来解决更多的图论问题，最基础使用DFS的问题就是迷宫问题。在进行搜索时，不断地向深处找下一个节点，如果没有下一个节点或下一个节点已经被访问的话，就回溯到有下一个节点可访问的点继续搜索。</p>
<p>如下图所示的图：</p>
<p><img src="/img/%E6%90%9C%E7%B4%A2/1563515220039.png" alt="1563515220039"></p>
<p>它的DFS遍历顺序为：$1 \rightarrow 2 \rightarrow 3\rightarrow 4 \rightarrow 5 \rightarrow 6 \rightarrow 7 \rightarrow 8 \rightarrow 9$（这个真的只是巧了）。</p>
<p>有的时候还需要得到带有回溯的DFS序，如图就为：$1\rightarrow 2\rightarrow 3 \rightarrow 4\rightarrow 5\rightarrow 4\rightarrow 6\rightarrow 7\rightarrow 6\rightarrow 8\rightarrow 9\rightarrow 8\rightarrow 6\rightarrow 4\rightarrow 3\rightarrow 2\rightarrow 1$</p>
<p>但DFS不仅仅只有搜索图那么简单还可以解决一些实际问题。如下题目（POJ 3900）：</p>
<blockquote>
<p>一个劫匪带着一个可装 $m$ 重量的超大背包去抢银行，银行有 $n$ 个大箱子，第 $i$ 个箱子里有 $i$ 个重量为 $w_i$ ，价值为 $c_i$ 的大钻石，问该劫匪抢走钻石的最大价值。（一共有 $T$ 组数据）</p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>$1\leq T \leq 74$；</p>
<p>$1 \leq n \leq 15$；</p>
<p>$1 \leq m \leq 1000000000\ (10^9)$；</p>
<p>$1 \leq w_i, c_i \leq 1000000000 \ (10^9)$。</p>
</blockquote>
<p>这道题看上去是一个01背包问题，但由于数据量巨大，无法开那么大的数组，所以只能使用DFS搜索。所以能够得到下面这段DFS代码：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> nowcost, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> lastw)</span></span>&#123;</span><br><span class="line">    <span class="hljs-comment">// pos:搜索的位置 nowcost:当前抢走的总价值 lastw:背包剩余的空间</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (pos == n || lastw &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// 如果搜到了最后一个箱子或者没空间了</span></span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    ans = max(ans, nowcost);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a[pos].num; i &gt;= <span class="hljs-number">0</span>; i--)&#123; <span class="hljs-comment">// 对每个箱子一个一个钻石的查</span></span><br><span class="line">        dfs(pos + <span class="hljs-number">1</span>, nowcost + i * a[pos].c, lastw - i * a[pos].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样太暴力了！TLE预定系列。所以我们要对我们的DFS进行一定的优化。</p>
<h1 id="深度优先搜索的优化"><a href="#深度优先搜索的优化" class="headerlink" title="深度优先搜索的优化"></a>深度优先搜索的优化</h1><p><strong>剪枝</strong>：对不满足条件的情况进行清除，减少算法所需要的时间，分为以下两种：</p>
<ul>
<li>可行性剪枝：判断搜索能否得出答案，如果不能的话直接回溯。</li>
<li>最优性剪枝：又称为上下界剪枝，是一种重要的剪枝策略。它记录当前得到的最优值，如果当前节点已经无法产生比当前最优解更优的解时，可以提前回溯。</li>
</ul>
<p>以上一个题目为示例，我们考虑它可能出现的剪枝方法：</p>
<ol>
<li><p>在枚举时，如果出现了$w_{\text{当前要去取的}} &gt; w_{\text{背包剩余的}}$，则直接跳过：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (i * a[pos].w &gt; lastw) <span class="hljs-keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>这是一种<strong>可行性剪枝</strong>。</p>
</li>
<li><p>在枚举时，如果$c_\text{已经拿了的} + c_\text{还没有拿的箱子的全部钻石} &lt; ans$，则不可能会出现更优解，所以回溯：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (nowcost + sum[pos] &lt; ans) <span class="hljs-keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>这是一种<strong>最优性剪枝</strong>。</p>
</li>
<li><p>在枚举时，设矿物的性价比为 $s$ ，$s_i = \displaystyle\frac{c_i}{w_i}$。如果 $w_\text{背包剩余的} * s_\text{还未偷的最大的} &lt; ans$，则不可能出现最优解，所以回溯。如果要石用这个剪枝的话，则要求在开始时就将这 $n$ 个箱子按照性价比从高到低进行排序，而 $n$ 的最大值也就只有 $15$ ，所以时间复杂度不高，完全可以满足要求。</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (nowcost + (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-built_in">ceil</span>(a[pos].s * lastw) &lt; ans) <span class="hljs-keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>这是一种<strong>最优性剪枝</strong>。</p>
</li>
</ol>
<p>另一个可以优化的搜索题目（POJ 1088）：</p>
<blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Michael 喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：<br>$$<br>\begin{eqnarray}<br>&amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\<br>&amp; 16 &amp; 17 &amp; 18 &amp; 19 &amp; 6 \\<br>&amp; 15 &amp; 24 &amp; 25 &amp; 20 &amp; 7\\<br>&amp; 14 &amp; 23 &amp; 22 &amp; 21 &amp; 8 \\<br>&amp; 13 &amp; 12 &amp; 11 &amp; 10 &amp; 9<br>\end{eqnarray}<br>$$<br>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。</p>
</blockquote>
<p><strong>记忆化搜索</strong>：记录以前搜索所得到的结果，当我搜索其他位置而需要这个位置的值时，我就可以直接使用这个值而减少搜索时间。</p>
<p>如在这个题目中，每个点到最低点的最优解是一定的，所以我在遍历的过程中可以记住已经遍历出结果的点，这样就可以节省很多的时间。</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (f[x][y] != <span class="hljs-number">0</span>) <span class="hljs-comment">// 已经记录了这个点的结果</span></span><br><span class="line">        <span class="hljs-keyword">return</span> f[x][y];</span><br><span class="line">    <span class="hljs-keyword">int</span> maxt = <span class="hljs-number">1</span>; 用以计数</span><br><span class="line">    <span class="hljs-keyword">int</span> t; <span class="hljs-comment">// test 用以记录中间结果</span></span><br><span class="line">    <span class="hljs-keyword">for</span>	(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123; <span class="hljs-comment">// 上下左右四个点</span></span><br><span class="line">        <span class="hljs-keyword">int</span> tx = x + dx[i], ty = y + dy[i]; <span class="hljs-comment">// dx[] 与 dy[] 是用来记录得到四个点坐标的操作数组</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(tx &gt; <span class="hljs-number">0</span> &amp;&amp; ty &gt; <span class="hljs-number">0</span> &amp;&amp; tx &lt;= r &amp;&amp; ty &lt;= c &amp;&amp; hill[tx][ty] &gt; hill[x][y])&#123;</span><br><span class="line">            t = dfs(tx, ty) + <span class="hljs-number">1</span>;</span><br><span class="line">            maxt = max(t, maxt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][y] = maxt; <span class="hljs-comment">// 记忆化</span></span><br><span class="line">    <span class="hljs-keyword">return</span> maxt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h1><p>BFS是一种使用队列实现的搜索算法，每次搜索对一层的节点进行搜索，所以最后呈现出来的结果是一圈一圈地扩大，具体过程如下图所示（其中Q为当前的队列信息，标有阴影的边为BFS算法所走过的边）：</p>
<p><img src="/img/%E6%90%9C%E7%B4%A2/1563521989690.png" alt="1563521989690"></p>
<p>由于BFS是一层一层地进行搜索，所以BFS很适合进行搜索到一个点最少步数类型的搜索。</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> stepArr[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 方向数组：分别为上下左右移动</span></span><br><span class="line"><span class="hljs-keyword">int</span> visited[x][y]; <span class="hljs-comment">// 标记是否已经被访问</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> x;</span><br><span class="line">    <span class="hljs-keyword">int</span> y;</span><br><span class="line">    <span class="hljs-keyword">int</span> step;</span><br><span class="line">    Node(<span class="hljs-keyword">int</span> x1,<span class="hljs-keyword">int</span> y1,<span class="hljs-keyword">int</span> step1):x(x1),y(y1),step(step1)&#123;&#125; <span class="hljs-comment">// 生成节点的函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-function">Node <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 生成一个节点</span></span><br><span class="line"><span class="hljs-built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    q.push(node);</span><br><span class="line">    <span class="hljs-keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="hljs-keyword">if</span>(node.x == n<span class="hljs-number">-1</span> &amp;&amp; node.y == n<span class="hljs-number">-1</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> node.step;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[node.x][node.y] = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)&#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> x = node.x + stepArr[i][<span class="hljs-number">0</span>];</span><br><span class="line">            <span class="hljs-keyword">int</span> y = node.y + stepArr[i][<span class="hljs-number">1</span>];</span><br><span class="line">            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; visit[x][y] == <span class="hljs-number">0</span> &amp;&amp; 其它条件 )&#123;</span><br><span class="line">                visit[x][y] = <span class="hljs-number">1</span>;</span><br><span class="line">                <span class="hljs-function">Node <span class="hljs-title">next</span><span class="hljs-params">(x,y,node.step+<span class="hljs-number">1</span>)</span></span>;</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span><span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="广度优先搜索的优化"><a href="#广度优先搜索的优化" class="headerlink" title="广度优先搜索的优化"></a>广度优先搜索的优化</h1><ul>
<li><p>双向广搜：从初状态和末状态两端进行广搜，直到两区域开始重叠或者有公众节点结束</p>
<p>如果一个节点产生的系统呈二叉树式增长，那么对于扩展 $n$ 次的代价， 单向为 $2^n$，而双向则是 $2 * 2^\frac{n}{2} = 2 ^{\frac{n}{2} + 1}$</p>
</li>
<li><p>利用散列表（Hash表）记录状态，避免遇到相同状态而增加搜索时间 </p>
</li>
</ul>
<p>如以下题目（洛谷P2730）：</p>
<blockquote>
<h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>在成功地发明了魔方之后，鲁比克先生发明了它的二维版本，称作魔板。这是一张有8个大小相同的格子的魔板：<br>$$<br>\begin{eqnarray}<br>&amp;1&amp;2&amp;3&amp;4 \\<br>&amp;8&amp;7&amp;6&amp;5<br>\end{eqnarray}<br>$$</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们知道魔板的每一个方格都有一种颜色。这8种颜色用前8个正整数来表示。可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。对于上图的魔板状态，我们用序列（1，2，3，4，5，6，7，8）来表示。这是基本状态。</p>
<p>这里提供三种基本操作，分别用大写字母“A”，“B”，“C”来表示（可以通过这些操作改变魔板的状态）：</p>
<p>“A”：交换上下两行；</p>
<p>“B”：将最右边的一列插入最左边；</p>
<p>“C”：魔板中央四格作顺时针旋转。</p>
<p>下面是对基本状态进行操作的示范：</p>
<p><strong>A</strong>:<br>$$<br>\begin{eqnarray}<br>&amp;8&amp;7&amp;6&amp;5 \\<br>&amp;1&amp;2&amp;3&amp;4<br>\end{eqnarray}<br>$$<br><strong>B</strong>:<br>$$<br>\begin{eqnarray}<br>&amp;4&amp;1&amp;2&amp;3 \\<br>&amp;5&amp;8&amp;7&amp;6<br>\end{eqnarray}<br>$$<br><strong>C</strong>:<br>$$<br>\begin{eqnarray}<br>&amp;1&amp;7&amp;2&amp;4 \\<br>&amp;8&amp;6&amp;3&amp;5<br>\end{eqnarray}<br>$$<br>对于每种可能的状态，这三种基本操作都可以使用。</p>
<p>你要编程计算用最少的基本操作完成基本状态到目标状态的转换，输出基本操作序列。</p>
</blockquote>
<p>A、B、C三种操作我们可以找到规则，写为函数来进行模拟，于是这样进行BFS。重点在于我们如何记录每一个状态。如果我们保留这8位数存储，使用一个8位的bool数组存储，判重时需要接近 $10^8$ 的布尔数组，空间接近200M，肯定超过限制。而我们最终需要的结果是操作的序列，所以我们不如使用操作序列来记录所有的状态。</p>
<p>所以有以下的AC代码（摘自洛谷巨佬<a href="https://www.luogu.org/blog/getchar123/solution-p2730" target="_blank" rel="noopener">getchar123</a>）：</p>
<figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-built_in">string</span> a;<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"><span class="hljs-built_in">string</span> a;</span><br><span class="line"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt;m;</span><br><span class="line"><span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">string</span>&gt;q;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-built_in">string</span> x)</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">string</span> xx=x;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">char</span> x1=x[i];</span><br><span class="line">        x[i]=x[<span class="hljs-number">7</span>-i];</span><br><span class="line">        x[<span class="hljs-number">7</span>-i]=x1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(m.count(x)==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//没有出现过</span></span><br><span class="line">        q.push(x);</span><br><span class="line">        m[x]=m[xx]+<span class="hljs-string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-built_in">string</span> x)</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">string</span> xx=x;</span><br><span class="line">    x[<span class="hljs-number">0</span>]=xx[<span class="hljs-number">3</span>],x[<span class="hljs-number">1</span>]=xx[<span class="hljs-number">0</span>],x[<span class="hljs-number">2</span>]=xx[<span class="hljs-number">1</span>],x[<span class="hljs-number">3</span>]=xx[<span class="hljs-number">2</span>],x[<span class="hljs-number">4</span>]=xx[<span class="hljs-number">5</span>],x[<span class="hljs-number">5</span>]=xx[<span class="hljs-number">6</span>],x[<span class="hljs-number">6</span>]=xx[<span class="hljs-number">7</span>],x[<span class="hljs-number">7</span>]=xx[<span class="hljs-number">4</span>];</span><br><span class="line">    <span class="hljs-keyword">if</span>(m.count(x)==<span class="hljs-number">0</span>)&#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">        m[x]=m[xx]+<span class="hljs-string">'B'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-built_in">string</span> x)</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">string</span> xx=x;</span><br><span class="line">    x[<span class="hljs-number">1</span>]=xx[<span class="hljs-number">6</span>],x[<span class="hljs-number">2</span>]=xx[<span class="hljs-number">1</span>],x[<span class="hljs-number">5</span>]=xx[<span class="hljs-number">2</span>],x[<span class="hljs-number">6</span>]=xx[<span class="hljs-number">5</span>];</span><br><span class="line">    <span class="hljs-keyword">if</span>(m.count(x)==<span class="hljs-number">0</span>)&#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">        m[x]=m[xx]+<span class="hljs-string">'C'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    q.push(<span class="hljs-string">"12345678"</span>);</span><br><span class="line">    m[<span class="hljs-string">"12345678"</span>]=<span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(q.empty()==<span class="hljs-literal">false</span>)&#123;</span><br><span class="line">        A(q.front());</span><br><span class="line">        B(q.front());</span><br><span class="line">        C(q.front());</span><br><span class="line">        <span class="hljs-keyword">if</span>(m.count(a)!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//当出现目标序列</span></span><br><span class="line">            <span class="hljs-built_in">cout</span>&lt;&lt;m[a].size()&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;m[a];</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">char</span> a1;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;a1;</span><br><span class="line">        a+=a1;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">string</span>&gt;m;</span><br><span class="line"><span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">string</span>&gt;q;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-built_in">string</span> x)</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">string</span> xx=x;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">char</span> x1=x[i];</span><br><span class="line">        x[i]=x[<span class="hljs-number">7</span>-i];</span><br><span class="line">        x[<span class="hljs-number">7</span>-i]=x1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(m.count(x)==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//没有出现过</span></span><br><span class="line">        q.push(x);</span><br><span class="line">        m[x]=m[xx]+<span class="hljs-string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-built_in">string</span> x)</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">string</span> xx=x;</span><br><span class="line">    x[<span class="hljs-number">0</span>]=xx[<span class="hljs-number">3</span>],x[<span class="hljs-number">1</span>]=xx[<span class="hljs-number">0</span>],x[<span class="hljs-number">2</span>]=xx[<span class="hljs-number">1</span>],x[<span class="hljs-number">3</span>]=xx[<span class="hljs-number">2</span>],x[<span class="hljs-number">4</span>]=xx[<span class="hljs-number">5</span>],x[<span class="hljs-number">5</span>]=xx[<span class="hljs-number">6</span>],x[<span class="hljs-number">6</span>]=xx[<span class="hljs-number">7</span>],x[<span class="hljs-number">7</span>]=xx[<span class="hljs-number">4</span>];</span><br><span class="line">    <span class="hljs-keyword">if</span>(m.count(x)==<span class="hljs-number">0</span>)&#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">        m[x]=m[xx]+<span class="hljs-string">'B'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-built_in">string</span> x)</span></span>&#123;</span><br><span class="line">    <span class="hljs-built_in">string</span> xx=x;</span><br><span class="line">    x[<span class="hljs-number">1</span>]=xx[<span class="hljs-number">6</span>],x[<span class="hljs-number">2</span>]=xx[<span class="hljs-number">1</span>],x[<span class="hljs-number">5</span>]=xx[<span class="hljs-number">2</span>],x[<span class="hljs-number">6</span>]=xx[<span class="hljs-number">5</span>];</span><br><span class="line">    <span class="hljs-keyword">if</span>(m.count(x)==<span class="hljs-number">0</span>)&#123;</span><br><span class="line">        q.push(x);</span><br><span class="line">        m[x]=m[xx]+<span class="hljs-string">'C'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    q.push(<span class="hljs-string">"12345678"</span>);</span><br><span class="line">    m[<span class="hljs-string">"12345678"</span>]=<span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(q.empty()==<span class="hljs-literal">false</span>)&#123;</span><br><span class="line">        A(q.front());</span><br><span class="line">        B(q.front());</span><br><span class="line">        C(q.front());</span><br><span class="line">        <span class="hljs-keyword">if</span>(m.count(a)!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//当出现目标序列</span></span><br><span class="line">            <span class="hljs-built_in">cout</span>&lt;&lt;m[a].size()&lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;m[a];</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;</span><br><span class="line">        <span class="hljs-keyword">char</span> a1;</span><br><span class="line">        <span class="hljs-built_in">cin</span>&gt;&gt;a1;</span><br><span class="line">        a+=a1;</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h1><p>（看到这里请提醒博主填完这里<del>或者删掉</del>）</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-image">
        <a href="/2019/07/17/某些数据结构（树状数组、差分对列、线段树）/" class="image is-7by1">
            <img class="thumbnail" src="/img/某些数据结构（树状数组、差分对列、线段树）/banner.jpeg" alt="算法学习：基础数据结构">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-17T05:49:51.000Z">2019-07-17</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    12 分钟 读完 (大约 1773 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/07/17/某些数据结构（树状数组、差分对列、线段树）/">算法学习：基础数据结构</a>
            
        </h1>
        <div class="content">
            <p>单调队列、树状数组、差分队列与线段树。</p>
        </div>
        
        
        <div class="level is-mobile">
            <div class="level-start">
                <div class="level-item">
                <a class="button is-size-7 is-light" href="/2019/07/17/某些数据结构（树状数组、差分对列、线段树）/#more">阅读更多</a>
                </div>
            </div>
        </div>
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/categories/Algorithm-study/page/0/">上一页</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/categories/Algorithm-study/page/2/">下一页</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/categories/Algorithm-study/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/categories/Algorithm-study/page/2/">2</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="is-rounded" src="/images/avatar.jpg" alt="KONGJUNE">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        KONGJUNE
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        💭️ Learning &amp; Looking...
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Tianjin, China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            15
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            3
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            5
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/kongjune" target="_blank">
                关注我</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/kongjune">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="QQ" href="http://wpa.qq.com/msgrd?v=3&amp;uin=974124729&amp;site=qq&amp;menu=yes">
                
                <i class="fab fa-qq"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="邮箱" href="mailto:ycysyxx@sina.com">
                
                <i class="fas fa-envelope"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="知乎" href="https://www.zhihu.com/people/kongjune-44">
                
                <i class="fab fa-zhihu"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://cardiffle.github.io/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Vicente&#39;s BLOG</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">cardiffle.github.io</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://zzy991212.github.io/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">ZZY&#39;s BLOG</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">zzy991212.github.io</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="http://www.callmelare.cn/blog/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Lare&#39;s BLOG</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.callmelare.cn</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://www.cnblogs.com/conver/" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Conver^_^&#39;s BLOG</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">www.cnblogs.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分类
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Algorithm-study/">
            <span class="level-start">
                <span class="level-item">Algorithm study</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">11</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Blog/">
            <span class="level-start">
                <span class="level-item">Blog</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Solution/">
            <span class="level-start">
                <span class="level-item">Solution</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            标签云
        </h3>
        <a href="/tags/ACM/" style="font-size: 17.5px;">ACM</a> <a href="/tags/Front-end/" style="font-size: 10px;">Front-end</a> <a href="/tags/Learning-Note/" style="font-size: 15px;">Learning Note</a> <a href="/tags/Programming/" style="font-size: 20px;">Programming</a> <a href="/tags/Solution/" style="font-size: 12.5px;">Solution</a>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/10/13/Hexo/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/Hexo/banner.png" alt="使用Hexo搭建个人博客并部署到Github">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-10-13T03:11:52.000Z">2019-10-13</time></div>
                    <a href="/2019/10/13/Hexo/" class="title has-link-black-ter is-size-6 has-text-weight-normal">使用Hexo搭建个人博客并部署到Github</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Blog/">Blog</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/14/马拉车算法/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/马拉车算法/banner.jpg" alt="算法学习：马拉车算法">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-14T08:55:52.000Z">2019-08-14</time></div>
                    <a href="/2019/08/14/马拉车算法/" class="title has-link-black-ter is-size-6 has-text-weight-normal">算法学习：马拉车算法</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/08/HDU6641/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/HDU6641/banner.jpg" alt="题解：HDU6641 TDL">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-08T10:59:52.000Z">2019-08-08</time></div>
                    <a href="/2019/08/08/HDU6641/" class="title has-link-black-ter is-size-6 has-text-weight-normal">题解：HDU6641 TDL</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Solution/">Solution</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/07/HDU6629/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/HDU6629/banner.jpg" alt="题解：HDU6629 String Mathching">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-07T04:00:09.000Z">2019-08-07</time></div>
                    <a href="/2019/08/07/HDU6629/" class="title has-link-black-ter is-size-6 has-text-weight-normal">题解：HDU6629 String Mathching</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Solution/">Solution</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/06/扩展KMP/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/扩展KMP/banner.jpg" alt="算法学习：扩展KMP">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-06T14:33:09.000Z">2019-08-06</time></div>
                    <a href="/2019/08/06/扩展KMP/" class="title has-link-black-ter is-size-6 has-text-weight-normal">算法学习：扩展KMP</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/10/">
                <span class="level-start">
                    <span class="level-item">十月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">七月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">10</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ACM/">
                        <span class="tag">ACM</span>
                        <span class="tag is-grey">14</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Front-end/">
                        <span class="tag">Front-end</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Learning-Note/">
                        <span class="tag">Learning Note</span>
                        <span class="tag is-grey">11</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Programming/">
                        <span class="tag">Programming</span>
                        <span class="tag is-grey">15</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Solution/">
                        <span class="tag">Solution</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/10/13/Hexo/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/Hexo/banner.png" alt="使用Hexo搭建个人博客并部署到Github">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-10-13T03:11:52.000Z">2019-10-13</time></div>
                    <a href="/2019/10/13/Hexo/" class="title has-link-black-ter is-size-6 has-text-weight-normal">使用Hexo搭建个人博客并部署到Github</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Blog/">Blog</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/14/马拉车算法/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/马拉车算法/banner.jpg" alt="算法学习：马拉车算法">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-14T08:55:52.000Z">2019-08-14</time></div>
                    <a href="/2019/08/14/马拉车算法/" class="title has-link-black-ter is-size-6 has-text-weight-normal">算法学习：马拉车算法</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/08/HDU6641/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/HDU6641/banner.jpg" alt="题解：HDU6641 TDL">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-08T10:59:52.000Z">2019-08-08</time></div>
                    <a href="/2019/08/08/HDU6641/" class="title has-link-black-ter is-size-6 has-text-weight-normal">题解：HDU6641 TDL</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Solution/">Solution</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/07/HDU6629/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/HDU6629/banner.jpg" alt="题解：HDU6629 String Mathching">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-07T04:00:09.000Z">2019-08-07</time></div>
                    <a href="/2019/08/07/HDU6629/" class="title has-link-black-ter is-size-6 has-text-weight-normal">题解：HDU6629 String Mathching</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Solution/">Solution</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/06/扩展KMP/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/img/扩展KMP/banner.jpg" alt="算法学习：扩展KMP">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-06T14:33:09.000Z">2019-08-06</time></div>
                    <a href="/2019/08/06/扩展KMP/" class="title has-link-black-ter is-size-6 has-text-weight-normal">算法学习：扩展KMP</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Algorithm-study/">Algorithm study</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/10/">
                <span class="level-start">
                    <span class="level-item">十月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">八月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">4</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">七月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">10</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/ACM/">
                        <span class="tag">ACM</span>
                        <span class="tag is-grey">14</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Front-end/">
                        <span class="tag">Front-end</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Learning-Note/">
                        <span class="tag">Learning Note</span>
                        <span class="tag is-grey">11</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Programming/">
                        <span class="tag">Programming</span>
                        <span class="tag is-grey">15</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Solution/">
                        <span class="tag">Solution</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="KONGJUNE&#39;s BLOG" height="28">
                
                </a>
                <span id="sitetime" class="is-size-7"></span>
                <p class="is-size-7">
                &copy; 2019 KONGJUNE&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
<script src="/js/animation.js"></script>

    
    
<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>

    
    
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>

    
    <script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>
    
    
<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>

    
    
    
    
    
    
    
    
    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>
