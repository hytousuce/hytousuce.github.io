{"pages":[{"title":"category","text":"","link":"/category/index.html"},{"title":"tag","text":"","link":"/tag/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"$Alia-Craft$","text":"致每一位服务器玩家： 非常抱歉，由于个人学业负担增加以及校内整体氛围不足，在12月12日租赁服务器到期后，本服务器将暂时停止运行。感谢每一位玩家曾经的陪伴。届时，我将会将服务器地图提取出来并发到群文件，有需要的玩家可以自行下载。 Minecraft 是我最热爱也是唯一热爱的游戏。可能在未来的某一天，此服务器将有幸重新运行。如果这有机会实现，希望大家可以继续支持。谢谢！ ——KONGJUNE 这里是由KONGJUNE （Minecraft 游戏名: kongjune） 构建的非公开 Minecraft 服务器 $Alia-Craft$ 的主页。 目前 $Alia-Craft$ 仍是一个不对外开放的、内部的（当前范围为天津大学校内）、纯净生存的小型服务器。 我们欢迎每一位对 Minecraft 带有热爱的玩家，并希望每一个玩家都能在这里找到自己热爱的天地。 如果你看好这个服务器，在服务器开放范围内（天津大学在校生）并且希望加入这个服务器，你有以下方式来获取这个服务器的入服资格： 在下方评论区表明“我想加入本服务器”并附上可用的联系方式（推荐QQ），以获取进一步审核资格； 添加服主QQ（974124729）并在好友申请处写明来意，来获取进一步审核资格； 在天津大学内部组织（如新生群、社团、小组织等）偶遇服主并恰好提起本服务器并成功获取审核资格（服主吐槽：这个机率太小了）； 恰好认识已在服务器中的玩家，以获取审核资格，或以担保的形式（以这种形式进入服务器不须满足必须为天津大学在读学生的范围限制，具体担保形式的介绍见下）进入服务器。 祝每一位玩家都能在 $Alia-Craft$ 玩得愉快！😉 服务器文化：$Alia-Craft$ 名字来源 选取服务器名称一事较仓促，未能完全与服务器其他成员进行沟通，在此表示诚挚的歉意！ $Alia$ 一词取自世界语（Esperanto），其为一形容词，含义为“另一个”。同时这也是一个好听的词语（发音类似中文拼音：ā-Lì-a），听起来也像是少女的名字。 取其“另一个”的含义，我希望这个服务器能类似于每个玩家心中的另一个世界，探索与建设自己想要的东西，每一个玩家也能像对待真实世界一样热爱这个世界。 服务器信息 服务器版本 📎 1.13.2 服务器游戏模式 ⚔️ 生存 & 创造（尚未开放） 最大在线人数 👥60人 正版验证 ❌ 关闭 服务器盈利模式 😀 公益性服务器 免费+接受“无条件”捐助 服务器 Change-log 2019 2019-08-12 $Alia-Craft$服务器 Change-Log Blog","link":"/mc/index.html"},{"title":"$Alia-Craft$ 服务器 Change-Log","text":"2019-8-2 更新了服务器头像； 方形渲染版本 圆形渲染版本 开启服务器版本化定义，并设置当前服务器版本为 0.1； 更改QQ群信息，如群头像、群名等内容。 2019-8-1 $Alia-Craft$ 主页部分基本建成； 生成 $Alia-Craft$ 的 Change-log 界面。","link":"/mc/minecraft-changelog/index.html"}],"posts":[{"title":"题解：HDU6641 TDL","text":"本题为 2019 HDU Multi-University Training Contest 6 的 1008 题。 题目传送门：🚪 Problem DescriptionFor a positive integer $n$, let’s denote function $f(n,m)$ as the $m$-th smallest integer $x$ that $x&gt;n$ and $\\mathrm{gcd}(x,n)=1$. For example, $f(5,1)=6$ and $f(5,5)=11$. You are given the value of $m$ and $(f(n,m)−n)\\oplus n$, where $\\oplus$ denotes the bitwise XOR operation. Please write a program to find the smallest positive integer $n$ that $(f(n,m)−n)\\oplus n=k$, or determine (whether) it is impossible. InputThe first line of the input contains an integer $T$($1 \\leq T \\leq 10$), denoting the number of test cases. In each test case, there are two integers $k,m$($1 \\leq k\\leq 10^{18}$,$1\\leq m\\leq100$). OutputFor each test case, print a single line containing an integer, denoting the smallest $n$. If there is no solution, output $-1$ instead. Sample Input12323 56 100 Sample Output125-1 顺便吐槽下出题人的英语水平，“or determine it is impossible” 是什么鬼？ 题意 &amp; 题解一道（对众多大佬来说比较水的）数论题，被拿来当签到题QAQ。 题目中，$(f(n,m) - n)\\oplus n=k$，我们设 $d = f(n,m) - n$，则有 $d \\oplus n = k$，两面同时异或上 $n\\oplus k$，则有 $d \\oplus n \\oplus n \\oplus k = k\\oplus n \\oplus k$ $\\Rightarrow$ $n = d \\oplus k$。$f(n,m)$ 表示大于 $n$ 的第 $m$ 大的与 $n$ 互质的数。由于 $m \\leq 100$，一个奇数周围与它互质的数一般要多于与它不互质的数（举个例子，假设一个奇数 $9$，它周围有 $10$、$11$、$12$、$13$、$14$、$15$、$16$、$17$、$18$、$19$、$20$，其中与它互质的有$11$、$13$、$14$、$16$、$17$、$19$、$20$，要多于不与它互质的个数），所以我去枚举 $d$ 的值要优于枚举 $n$ 的值，况且一个数与它相邻的数一定是互质的，所以我们从 $1$ 开始枚举 $d$ 就可以了。枚举 $d$ 带入 $n = d \\oplus p$ 得到的 $n$ 带回 $d=f(n,m)-n$ 中进行验证，如果成立，则代表这个结果是可行的。$f(n,m) = n + d$，$f(n,m)$ 满足与 $n$ 互质，即 $\\mathrm{gcd}(f(n,m), n) = 1$，根据更相减损术，$\\mathrm{gcd}(f(n,m) - n,n)$ $=$ $\\mathrm{gcd}(f(n,m)，n)$，所以枚举 $d$ 后通过判断 $d$ 与 $n$ 是否互质可以排除很多不满足的情况。而 $d$ 的枚举我们只需要枚举到第 $115$ 个质数，理由如下： 根据算术基本定理（唯一分解定理），任何一个大于 $1$ 的合数自然数 $N$，都可以分解成有限个质数的乘积，即：$$N = P_1^{a_{1}}P_2^{a_{2}}P_3^{a_{3}} \\cdots P_n^{a_{n}}=\\prod_{i=1}^nP_i^{a_i}$$根据约数个数定理，一个数的因数个数 $K$ 为：$$K = (a_1+1)(a_2+1)(a_3+1)\\cdots(a_k+1)=\\prod_{i=1}^n(a_i+1)$$最终结果 $n$ 不会超过long long的范围，而前 $16$ 个质数之积已经超过了long long的范围，也就是说，最小的一个可分解为 $15$ 个以上质数的数已经不符合要求了，所以最终结果 $n$ 最多有 $15$ 质数因数。而根据更相减损术，如果对于一个质数 $x$ 与一个自然数 $n$ 互质，则 $x$ 也与 $x+n$ 互质。如果我们根据算术基本定理对 $n$ 分解后它有 $15$ 个素数因数，那么第 $115$ 个素数（即 $631$）一定会是 $d$ 可以取到的极限了。所以 $d$ 只需要从 $1$ 枚举到 $631$，超出此范围就一定没有满足的结果了。 AC代码来自同队的 zyg 大佬，感谢大佬！ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std ;typedef long long ll ;ll gcd (ll x , ll y){ if (y==0) return x ; else return gcd(y,x%y) ;}const ll maxn = 1e18+5 ;int main(){ int t ; scanf(\"%d\",&amp;t) ; while(t--){ ll k ; int m ; ll ans = maxn ; scanf(\"%lld %d\",&amp;k , &amp;m) ; for (ll i = 1; i &lt;= 631 ; i++) { // 631是第115个质数 ll n = i^k ; if (gcd(i,n)!=1) continue ; int temp = 0 ; for (ll j = 1 ; j&lt; i ; j++) { if (gcd(j,n)==1) temp++ ; } if (temp==m-1&amp;&amp;ans&gt;n){ ans = n ; } } if (ans == maxn) cout &lt;&lt; -1 &lt;&lt; endl ; else cout &lt;&lt; ans &lt;&lt; endl ; } return 0 ;}","link":"/2019/08/08/HDU6641/"},{"title":"算法学习：字典树、KMP与AC自动机","text":"字典树 学习自博客：https://blog.csdn.net/qq_42815188/article/details/88677836 字典树（又称为单词查找树，Tire 树）是一种树形结构。它与字典相似，当要查找的一个单词是否在字典树中，首先看单词的第一个字母是否在字典树的第一层。如果不在，说明字典树中没有该单词；如果在，就在该单词的子节点中找是否有单词的第二个字母，如果没有，则说明没有此单词，有的话就继续查找，以此类推。 字典树有以下的基本性质： 字典树使用边表示字符；（也可以理解为每个节点上保存字符，因为这个边的信息是使用j节点来标识的） 有相同的前缀的单词共用前缀节点； 根结点不包含有字符； 每个单词结束的时候都用一个特殊字符表示，如图中使用的是一个 $ \\$ $ 符号；（或者使用数字表示存在该字符串的个数） 从根结点道到一个 $ \\$ $ 所经过的所有边的字母就是一个字符串。 字典树常用于统计、排序和保存大量的字符串（不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。 优点：利用字符串的公众前缀来节约存储空间，最大限度地减少无用字符串的比较。 构建字典树编号方案引入数组tire[][]。tire[i][j] = k表示：tire树中编号为i的节点的边上为字母(char)( 'a' + j )的儿子为编号为j的节点（这里不用于一般的树的储存方式）。而这个节点应存储的信息（如这个单词出现了多少次）则单独开一个以编号为下标的数组来记录。 以此种方式标记好的字典树将如下图所示：（图中的数字指的是这条边结尾处的节点的编号，其中根结点编号为 $0$）。 插入操作当有新的需要插入的词语（字符串）出现时，我们就依次对比每一个字母在对应层中是否已经出现来判断新进入的词语是否与已经存在的词相同或语有相同的前缀。当出现差异时，我们就标记激活这个节点（标记这个节点为单词词尾节点并将其值（指另一个存储该节点信息的值）加一）。相同词语则直接使词尾节点的值（指另一个存储该节点信息的值）递增。具体操作如下代码： 1234567891011121314151617181920// 实例为字符串中只有'a'~'b'26个字母的字典树#define SIGMA_SIZE 26// MAXN_NODE根据题意进行赋值int tire[MAXN_NODE][SIGMA_SIZE] = {0}; int tag[MAXN_NODE] = {0}; // 标记编号为i的节点是否为单词节点int cnt[MAXN_NODE] = {0}; // 记录编号为i的单词节点所对应的单词出现次数int node = 0; // Trie树的节点个数void Insert(string str){ int now = 0; // 用以记录目前遍历到的节点编号 int len = str.length(); for(int i = 0; i &lt; len; i++){ if(!tire[now][str[i] - 'a']){ // 如果这个节点未曾有子节点（前缀出现偏差） tire[now][str[i] - 'a'] = ++node; } now = ch[now][str[i] - 'a']; } tag[now] = true; cnt[now] ++;} 查询操作只要建树搞得好，这就莫的问题。 123456789101112131415// 如果找到则返回词的个数，如果没有找到或无该词则返回-1int find(string str){ int len = str.length(); int now = 0; for(int i = 0; i &lt; len; i++){ int c = str[i] - 'a'; if(tire[now][c] == 0){ // 没有子节点了，也就是这个单词不存在实锤 return -1; } now = trir[now][x]; } if(tag[now]) return cnt[now]; else return -1;} KMP 算法 学习自博客：https://blog.csdn.net/v_july_v/article/details/7041827 Knuth-Morris-Pratt 字符串查找算法，简称 KMP 算法，常用在于一个文本串S内查找一个模式串P的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人联合发表，故取这三个人的姓氏命名此算法。 传统的模式串匹配使用的是纯暴力匹配算法。 纯暴力匹配 如果当前字符匹配成功（S[i] == P[j]），则i++、j++，继续匹配下一个字符； 如果没有匹配成果（S[i] != P[j]），则令i = i - (j - i)（回溯到开始匹配的字符的下一个字符）、j = 0，重新匹配模式串。 如以下的图解（假设文本串S = &quot;BBC ABCDAB ABCDABCDABDE&quot;，模式串P = &quot;ABCDABD&quot;）： 首先从第0位开始匹配： 发现匹配不成功，则匹配串右移。 匹配文本串的第1位： 发现依旧不匹配，继续将匹配串右移。 直到出现了一次匹配（匹配串移动到了第4位）： 发现匹配成功，则i++、j++。对下一位进行匹配。 将文本串的第5位与匹配串的第1位匹配： 发现匹配成功，继续i++、j++。对下一位匹配，直到出现不能匹配的项。 再次出现不能匹配的项： 发现匹配不成功，则匹配串右移，重新从匹配串的第一位开始进行匹配。 じゃ、もう一度！ 从示例可以看出，这种匹配模式下，每次出现错误的匹配都需要回溯到词头再进行匹配，十分的低效，算法复杂度也到了$O(m\\cdot n)$。如果我们在进行匹配的时候，能基本做到不进行回溯而只移动模式串的话，算法复杂度将极大地提升。 KMP算法匹配字符串让我们回到起点重新进行模式串匹配： 首先匹配文本串的第0位： 发现匹配不成功，则匹配串右移。 匹配文本串的第1位： 发现依旧不匹配，继续将匹配串右移。 直到出现了一次匹配（匹配串移动到了第4位）： 发现匹配成功，则i++、j++。对下一位进行匹配。 将文本串的第5位与匹配串的第1位匹配： 发现匹配成功，继续i++、j++。对下一位匹配，直到出现不能匹配的项。 再次出现不能匹配的项： 发现匹配不成功，则匹配串右移，重新从匹配串的第一位开始进行匹配。 这时我们考虑，真的要回溯到文本串的第5位然后重新开始与模式串的第一位进行比较么？我们可以发现我们已经匹配了的部分中有一段字符串&quot;AB&quot;，而模式串的前缀中也有&quot;AB&quot;。也就是说，其实我们可以认为已经将模式串的前两位匹配成功了，我们只需要继续匹配模式串的第2位（从0开始编号）就可以了。 不进行回溯而将模式串右移一定的位： 发现匹配错误，将模式串继续移位。 移位将字符串的第10位与模式串第0位进行匹配： 发现匹配错误，移位对字符串的下一位进行匹配。 移位将字符串第11位与模式串第0位进行匹配： 发现匹配成功。则i++、j++，进行下一位匹配。以此类推，直到再次发生不能匹配。 直到再一次发生匹配失败： 情况与上一次相似，都是出现在了'D'位，所以模式串向右移动。 模式串向右移动四位： 发现匹配成功，则不断的i++、j++。 匹配完成： 这种匹配方式下，字符串完全不需要进行回溯，只需要将模式串进行一定量的右移就可以得到最终结果。这是一种高效的模式串匹配方法。算法的时间复杂度仅为 $O(m + n)$。 那么这个算法的重点就是在于：模式串应该如何的右移，也就是当发生匹配失败时，我应该去匹配模式串的哪一位？所以我们引进了next[]数组。 从我们过程的分析中可以发现，我们判断需要将模式串向右移动几位是依据我们的模式串的开头部分与结尾部分中是否有重复出现的一部分，如果存在，我们就可以移动模式串使着相同的部分重合，从而节省了前面一段部分的匹配。所以我们要找出这一位以前（包括这一位）前缀与后缀的数量的这个子串中出现的最长的具有相同元素的前缀与后缀。我们可以得到如下表格： 模式串的各个子串 前缀 后缀 最大公共元素长度 A 空 空 0 AB A B 0 ABC A, AB C, BC 0 ABCD A, AB, ABC D, CD, BCD 0 ABCDA A, AB, ABC, ABCD A, DA, CDA, BCDA 1 ABCDAB A, AB, ABC, ABCD, ABCDA B, AB, DAB, CDAB, BCDAB 2 ABCDABD A, AB, ABC, ABCD, ABCDA, ABCDAB D, BD, ABD, DABD, CDABD, BCDABD 0 字符 A B C D A$_1$ B$_2$ D 最大前缀后缀公共元素长度 0 0 0 0 1 2 0 而nect[]数组的作用是，重复到拥有相同前缀的位置。所以我这一位要回到哪里要看的是这一位之前的字符串中最长长度的拥有的相同的前后缀的长度为多少。而对于第一位，他之前没有字符串，所以我需要做的是将字符串右移一位然后进行重新匹配，所以next[0]的值应为 $-1$ 。所以next[]数组的值即为将最大前缀后缀公共元素长度表的内容全体后移一位然后将第0位赋值成 $ -1$ 即可！示例的next[]数组如下： 字符 A B C D A$_1$ B$_1$ D next[]对应位的值 -1 0 0 0 0 1 2 而在求模式串的next[]数组的过程中，我需要找到模式串子串的前后缀，即比对模式串子串与模式串是否有相同部分的内容，同样可以使用KMP算法，所以我们在求后面几位的next[]时完全可以用到前面几位的next[]的值。 求得next[]数组的代码如下： 1234567891011121314151617void GetNext(string p,int next[]){ int p_len = p.length(); next[0] = -1; int k = -1; int j = 0; // 标记目前在计算第几位的next值 while (j &lt; p_len - 1){ //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) { // 初始状态或者需要右移或者匹配成功 ++k; ++j; next[j] = k; } else { k = next[k]; // 匹配失败 } }} 在使用KMP算法匹配字符串的算法如下： 12345678910111213141516int KMPSearch(string str, string p){ int i = 0, j = 0; int str_len = str.length(); int p_len = p.length(); while (i &lt; str_len &amp;&amp; j &lt; p_len){ if (j == -1 || s[i] == p[j]){ // 如果需要后移或者匹配成功 i++; j++; }else{ // 如果匹配失败 j = next[j]; } } if(j == p_len) // 匹配成功 return i - j; else return -1; // 匹配失败} AC 自动机 学习自博客：https://blog.csdn.net/bestsort/article/details/82947639 AC自动机是以字典树作为搜索数据结构，利用KMP原理减少回溯的操作，以实现多模式串匹配。算法复杂度优化到了 $O(n)$。 AC自动机就是在字典树的基础上，增加上一个fail指针，如果当前点处匹配失败的话，就将指针转移到fail指针所指的位置，来减少没有必要的回溯。（类似KMP中的next[]的作用） 如我现在有待匹配的串，为&quot;shershisher&quot;。我现在有模式串&quot;hers&quot;、&quot;hrs&quot;、&quot;she&quot;，形成如图所示的字典树： fail指针的作用就是在我出现匹配失败的时候，我能立刻转移到相近的能继续匹配下去的串而不需要重新再来。所以我们需要找出在不同模式串中前缀匹配的部分。fail指针的构建都是用BFS来实现的，基本的操作就是指向节点的父节点fail指针所指向的节点的子节点中与其相同的节点，如果没有，则指向它父亲节点的fail指针指向的节点。以如图所示的字典树，我对他进行fail指针构建： 第一层遍历，每个串的首字母肯定是指向根节点： 第二层遍历，我们瞄准最左面的子树的第一个节点（被e指向的绿色节点）： 应指向他的父节点（h指向的橙色节点）的fail指针指向的节点（蓝色的根结点）的子节点中指向边为e的节点，不存在，所以指向他父节点的fail指针指向的节点（根结点） 第二层的第二个节点，相同。接下来看第三个节点（被h指向的绿色节点）： 应指向他的父节点（s指向的橙色节点）的fail指针指向的节点（蓝色的根结点）的子节点中指向边为h的节点（h指向的橙色节点）。所以得到如下图： 依次如此作图，最终得到如下图（有点乱）： 在我进行字符串&quot;shershisher&quot;匹配时，首先匹配&quot;she&quot;成功，ans++。e之后没有字符继续匹配，所以指向fail指针指向的另一个e即开始匹配&quot;hers&quot;，匹配成功，ans++。后s指向最右侧树的s，开始匹配&quot;she&quot;，匹配到h后失配，所以指向fail开始匹配&quot;hers&quot;，到s匹配失败。所以最终结果为 $2$。","link":"/2019/07/22/AC自动机/"},{"title":"题解：HDU6629 String Mathching","text":"本题为 2019 HDU Multi-University Training Contest 5 的 1007 题。 题目传送门：🚪 Problem DescriptionString matching is a common type of problem in computer science. One string matching problem is as following: Given a string $S[0\\cdots len−1]$, please calculate the length of the longest common prefix of $S[i\\cdots len−1]$ and $S[0 \\cdots len−1]$ for each $i&gt;0$. I believe everyone can do it by brute force.The pseudo code of the brute force approach is as the following: We are wondering, for any given string, what is the number of compare operations invoked if we use the above algorithm. Please tell us the answer before we attempt to run this algorithm. inputThe first line contains an integer $T$, denoting the number of test cases.Each test case contains one string in a line consisting of printable ASCII characters except space. $1 \\leq T \\leq 30$ string length $\\leq 106$ for every string OutputFor each test, print an integer in one line indicating the number of compare operations invoked if we run the algorithm in the statement against the input string. Sample Input1234 3_Happy_New_Year_ywwywwzjczzzjczjczzzjc Sample Output12317732 题意 &amp; 算法题目就是问题目中这个算法中比较的次数。题目中提及的算法就是暴力对串中每一个位置进行前缀匹配。我们可以推知，如果子串长度为 $x$ ，我们就需要进行 $x+1$ 次匹配（因为还有一次匹配失败的情况）。而如果我匹配的子串最后一位到达了原串的最后一位的话，我们只需要进行 $x$ 次匹配（因为匹配失败的情况不会出现了）。所以这个问题就转换成了前缀匹配。扩展KMP算法就是为这种问题产生的。 KMP算法讲解传送门：🚪 这个题挺坑的，各种卡时间啊。卡memset()（其实也没必要用memset()），卡cin……T 了一晚上我才过去…… AC代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int nexts[1000006];char T[1000006];long long ans = 0;void getNext(){ int m = strlen(T); // m:T的长度 int a = 0, p = 0; for (int i = 1; i &lt; m; i++) { if (i &gt;= p || i + nexts[i - a] &gt;= p) { if (i &gt;= p) p = i; while (p &lt; m &amp;&amp; T[p] == T[p - i]) p++; nexts[i] = p - i; if(i + nexts[i] &gt;= m) ans += nexts[i]; else ans += nexts[i] + 1; a = i; } else{ nexts[i] = nexts[i - a]; if(i + nexts[i] &gt;= m) ans += nexts[i]; else ans += nexts[i] + 1; } }}int main(){ int n; scanf(\"%d\", &amp;n); while(n--){ scanf(\"%s\", T); ans = 0; getNext(); printf(\"%lld\\n\", ans); } return 0;}","link":"/2019/08/07/HDU6629/"},{"title":"使用Hexo搭建个人博客并部署到Github","text":"操作系统环境：Ubuntu 19.04 Git版本：2.20.1 Node.js版本：10.15.2 npm版本：5.8.0 前置环境安装安装前提在你的电脑上安装 Git、Node.js 以及 npm： 1sudo apt install git nodejs npm 在某些发行版，源中的 nodejs 与 npm 版本过低，不能完成 Hexo 的正常使用，如果出现这种问题，请到 Nodejs 官网以及 npm 官网下载较新版本。 安装hexo1sudo npm install -g hexo-cil 初始化你的博客在你希望创建博客的目录下运行指令： 1hexo init 由于 npm 的问题，我在运行本命令的时候出现了错误，如下图： 只需要再手动运行 npm install 命令就可以了。 执行本命令后，我们会发现在当前目录下多出了以下文件： 其中： node_modules：nodejs的依赖包，各种插件会被安装在里面； scaffolds：页面模板； source：资源，这里面的内容将会按照页面分别，未来也将会呈现在生成的静态页面中； 如我在这个目录中创建了 img 文件夹并在其中放置了 index.jpg 文件，预览或者发布后在浏览器中输入页面地址/img/index.jpg即可访问这个文件。而以 markdown 编写的博客文件将会被转换成 html 文件并按照配置中的设置来保存到静态页面结构中。 theme：存放主题的文件夹，默认安装 landscape 主题； _config.yml：配置文件，具体内容将会在后面的内容中提及。 此时输入以下命令（实时预览博客）： 1hexo server 并在浏览器中输入：http://localhost:4000，你就可以看到你的博客最开始的样子了。 增加你的第一篇博客使用如下命令创建一篇博客： 1hexo new '文章名' 比如我想创建一篇叫做 test 的博客，我就需要输入 hexo new 'text'（去掉引号也是可以的）。接下来我们就可以在/source/_posts文件夹下看到我刚刚创建的text.md文件。打开我们会发现上面已经有一部分内容： 这一部分灰色背景框住的部分叫做 Font-matter，用于指定个别文件的变量。它具体的markdown代码为： 12345---title: testdate: 2019-10-13 11:38:55tags:--- Hexo 预先定义了一些参数： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期与时间 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章地址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） 除了使用 YAML 你也可以使用 JSON 来编写 Front-matter，例如： 123\"title\": \"Hello World\",\"date\": \"2013/7/13 20:46:25\";;; Font-matter以下，你就可以使用熟悉的 markdown 来编写你的博文了。 配置你的博客的一些基础配置可以在_config.yaml中来修改，具体内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo # 博客标题，会显示在你的页面标题中subtitle: # 副标题description: # 描述，用于告诉搜索引擎keywords: # 关键词author: John Doe # 作者，你的名字language: en # 语言，简体中文设置为 zh-CNtimezone: # 时区，东八区设置为 Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com # 网址，具体见下文描述root: / # 网站根目录permalink: :year/:month/:day/:title/ # 网站的永久连接格式，具体见下文描述permalink_defaults: # 永久连接中各部分的默认值# Directory # 这些目录将会与你的主题设置等有关source_dir: source # 资源文件夹名称public_dir: public # 发布文件夹名称，这个文件夹用于存放生成的站点文件tag_dir: tags # 标签文件夹名称 archive_dir: archives # 归档文件夹名称category_dir: categories # 分类文件夹名称code_dir: downloads/code # Include code文件夹，是source_dir下的子目录i18n_dir: :lang # 国际文件夹skip_render: # 跳过指定文件的渲染，发布时不会生成这些文件# Writingnew_post_name: :title.md # 新文章的文件名称default_layout: post # 预设布局，post即按照主题中layout文件夹下的post.ejs来布局auto_spacing: false # 在中英文之间自动加入空格titlecase: false # 把标题转换为title caseexternal_link: true # 在新标签页中打开连接filename_case: 0 # 把文件名称转换为 (1)小写 或 (2)大写 (0)不转换render_drafts: false # 显示草稿(?)post_asset_folder: false # 启动 Asset 文件夹(?)relative_link: false # 把链接改为与根目录的相对位址future: true # 显示未来的文章（按照Front-matter中的data属性判断）highlight: # 代码块高亮 enable: true # 启用高亮 line_number: true # 显示行号 auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: # 主页设置 path: '' # 路径 per_page: 10 # 每页显示的文章个数 order_by: -date # 按照日期排序 # Category &amp; Tagdefault_category: uncategorized # 默认的分类category_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD # 日期格式time_format: HH:mm:ss # 时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 分页：每页现实的文章量pagination_dir: page # 分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 设置主题# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: # 部署设置 type: 特殊的： 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 当permalink设置为:year/:month/:day/:title/时，你的生成于2019年10月1日的名为Hello的博客将以http://你博客的网址/2019/10/01/Hello/来访问。 主题在 Hexo 主题商店 来找到你的想要的主题。 一个主题文件夹中主要有以下文件/文件夹： _config.yml：主题的配置文件； languages：主题的语言文件； layout：页面布局方案； scripts：脚本文件； source：资源文件。 由于不同主题的具体内容不同，所以在此不再对主题的配置进行讨论。 部署到 Github Github Pages 是 Github 提供的免费的静态网站解决方案，用以方便用户发布自己的项目。Github Pages 为每一个用户提供一个静态网站，域名为 &lt;username&gt;.github.io。用之搭建静态的个人博客是很好的选择的 在Github的设置创建一个名为 &lt;username&gt;.github.io 的仓库，注意 &lt;username&gt; 部分一定要替换成你的用户名: 在本地Git中配置你的Github账户信息在终端中输入以下命令： 12git config --global user.name \"YourName\"git config --global user.email \"YourEmail\" 将其中的YourName与YourEmail修改成你的用户名和账户邮箱。 再输入以下命令创建SSH: 1ssh-keygen -t rsa -C \"youremail@example.com\" 按照图片中的内容找到生成的id_rsa.pub，并将内容复制到 Github 设置中的 SSH keys 中。 再输入以下命令来确认 SSH 连接： 1ssh -T git@github.com 在Hexo中配置上你的 Github 信息修改博客的_config.yml中关于 deploy（部署）的配置（将其中的&lt;username&gt;改成你的 github 用户名，内容不保留尖括号）： 12345deploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master message: 在你的博客目录下打开终端，输入以下命令： 123hexo cleanhexo generatehexo server hexo clean/hexo c：清除本地以前生成的静态页面文件。 hexo generate/hexo g：在本地生成静态页面文件，并保存到public文件夹下。 hexo deploy/hexo d：上传部署到 Github。 部署完成后，就可以在浏览器中访问http://username.github.io（username替换为你的Github用户名）来访问你的博客了。 其他绑定个人域名 购买域名，国内的话可以购买的地方很多，推荐阿里云万网。 个人认为还是.com与.net的域名更好一些，但相对其他域名来说活动会更少。你也可以尝试现在个人博客多使用的.cc、.name、.me、.io等域名。 增加CNAME，在你的source目录下藤甲一个名为CNAME文件，并在里面增加上你的域名。 在你的域名解析DNS中增加上记录： 记录类型 主机记录 解析路线 记录值 A www 默认 IP地址 CNAME @ 默认 你的github页面网址 记录类型： A：指定主机对应的IP地址； CNAME：别名记录； NS：域名服务器记录； MX：邮件交换记录，指向邮箱服务器。 我们在这里只需要记录一个 A 记录和一个 CNAME 记录就可以了。 主机记录（域名前缀： @：直接解析主域名，没有前缀； 某一个英文字符串：前缀为这个字符串的域名； ：泛解析，匹配其他所有前缀域名。 其中IP地址可以通过ping命令获得： 重新部署。 hexo-admin 插件hexo-admin插件是一个方便后台登录管理hexo博客的插件，你可以在这上面方便地创建并编写新博客。 安装本插件在博客目录下打开终端并输入： 1npm install --save hexo-admin 使用本插件首先你要在本地预览你的博客，输入： 1hexo server 然后打开浏览器访问localhost:4000/admin即可进入该插件后台。 配置本插件为防止他人试用本插件，我们可以在设置中添加用户名密码。在 Settings 中找到 Setup authentification here。 设置你的用户名和密码。 然后将下方生成的配置文件内容存放到博客配置文件_config.yml中，即可加密。","link":"/2019/10/13/Hexo/"},{"title":"算法学习：倍增思想","text":"个人认为来源于二进制的思想。 对于如图式的一系列区域。 以往的记录方式，都是从A出发，走一步到了A右面一格，走两步到了A右面两格位置，……，走11步，走到了B位置。这样记录的话，每个节点都需要记录 $n - i$ 条内容，全部也就是需要 $\\frac{n(n-1)}{2}$条，也就是 $O(n^2)$ 的空间复杂度。而由于每个数都可以写为2进制，那么每个点我只需要记录走一步、走两步、走四步、走八步……的位置，比如从A点，我可以走 $1+2+8=11$ 步到达B，也就是读取A走1步后在读取目前这个格子走两步再读取目前这个格子走八步的位置就可以到达B点。 而对于每一个点，走4步的位置就相当于走两步后的位置再走两步，走八步的位置就相当于走两步的位置再走两步再走两步……以此类推。 位运算符 位运算符为二进制运算符，所以是将参与运算的数据转换为二进制后进行运算。按右对齐，左补符号位运算。 &gt;&gt;：右移运算符，右移 $i$ 位相当于将该数乘以了 $2^i$。 &lt;&lt;：左移运算符，左移 $i$ 位相当于将该数除以了 $2^i$。 &amp;：按位与运算，如 $5 &amp; 3$ 相当于即为$(0101)_2 &amp; (0011)_2 = (0001)_2$，所以结果为$1$。 |：按位或运算 ，如 $5 \\ | \\ 3$ 相当于 $(0101)_2\\ |\\ (0011)_2 = (0111)_2$，所以结果为$7$。 ~：按位取反。 ^：异或运算符，如 $5 \\ \\text{^} \\ 3$ 相当于 $(0101)_2\\ \\text{^} \\ (0011)_2 = (0110)_2$，所以结果为$6$。 异或交换律：$a\\otimes b = b\\otimes a$ 异或结合律：$(a\\otimes b)\\otimes c= a\\otimes(b\\otimes c)$ 异或自反性：$a\\otimes b\\otimes b=a\\otimes 0=a$ 对于任何数都有：$x\\otimes x =0$、$x\\otimes 0=x$ &amp;=、|=、&gt;&gt;=、&lt;&lt;=、^=：位运算的复合赋值运算符 快速幂1234567template &lt;class T&gt;T quick_power(T x,T y){ // 求x^y int p = 1; for(int i = y; i; i &gt;&gt;= 1, x = x * x) if(i &amp; 1) p = p * x; return p;} i &gt;&gt;= 1：即i /= 2，用于不断地向右取幂次数的二进制位。 i &amp; 1：用以判断对应这一二进制是否需要进行$\\times x^{2^{cnt}}$（$cnt$ 为要进行的幂次方数，由 x = x * x 语句决定）处理。 原理即为对于任意的被幂次数都可以写为2进制形式。如$13$可写为$1101$，那么$5^{13} = 5^{2^3\\times1+2^2\\times1+2^1\\times0+2^0\\times1}=5^{2^3} \\times 5^{2^2}\\times 5^{2^0}$ 设最开始x值为 $x$，第i次循环x值为 $x_i$，则可以得到 $x_i = x^{2^i}$。 ST表ST表是一种离线查询表，用以查找特定区间内的最大（最小）值。预处理的时间复杂度为$\\text O(n\\log n)$，查找时间复杂度为$\\text O(1)$，优于线段树（线段树的预处理与查找的复杂度均为$\\text O(n\\log n)$）。 st[x][y] 用以查询区间$[x,x+2^y-1]$内数的最大（最小）值，也就是从 $x$ 开始的 $2^y$ 个数的最大（最小）值。 st[x][y] 是a[x]本身。 预处理（实例中为查找最小值的ST表）1234567891011121314int a[1010];//原始输入数组int st[1010][20];//st表void init(int n){ for (int i = 0; i &lt; n; i++) st[i][0] = a[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) { for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i++) st[i][j] = min(st[i][j - 1],st[i + (1 &lt;&lt; (j - 1))][j - 1]); }} 1 &lt;&lt; j 相当于求出$2^j$的值 $\\text{st}[x][y] = max/min(\\text{st}[i,j-1],\\text{st}[i+2^{j-1},j-1])$：将$[x,x+2^y-1]$（指序号大小，下同）分为$[x,x+2^{y-1}-1]$与$[x+2^{y-1},x+2^y-1]$两部分 因为j是从小到大遍历的，所以在得到st[i][j]的值之前，一定会得到st[i + (1 &lt;&lt; (j-1))][j - 1]的值 查找（实例为查找最小值）查找区间$[l,r]$内的最小值： 12345int search(int l, int r){ int k = (int)(log((double)(r - l + 1)) / log(2.0)); return min(st[l][k],st[r - (1 &lt;&lt; k) + 1][k]);} 有定理： $2^{\\log_2 a}&gt;\\frac{a}{2}$ 成立。如果设 $t = \\log_2{len}$，其中 $len$ 为从 $l$ 到 $r$ 的长度（$len = r-l+1$），则有$2^{\\log_2len} &gt; \\frac{len}{2} \\Rightarrow 2^t &gt; \\frac{len}{2}$ 成立，所以 $l+2^t$ 跨过了区间的中间位置，那么我们可以得到 $l$ 到 $r$ 的最小值是 $l$向前 $2^k$ 长度区间与 $r$ 向前 $2^k$ 长度区间的最小值的最小值。所以区间 $[l,r]$ 内的最小值为min(st[l][k], st[r - (1 &lt;&lt; k) + 1][k])。 LCA LCA：最近公共祖先。 从 LCA 的定义可以得到：两点的 LCA 一定是两个点的祖先中深度最大的。那么也就是说两个点如果深度相同的话，他们沿着树向上走x步就可以同时到达 LCA 。 如果深度不同，则深度较大的向上跳到深度相同的地方。 如果深度相同，则一同向上跳到找到 LCA。 倍增法求LCA123456789101112131415int lca(int a, int b){ if(depth[a] &lt; depth[b]) swap(a, b); int c = depth[a] - depth[b]; for(int i = 20; i &gt;= 0;i--) if(c &amp; (1 &lt;&lt; i)) a = fa[a][i]; // if(u == v) return u; for(int i = 20;i &gt;= 0;i--) if(fa[a][i]!=fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];} 其中数组fa[a][x]表示的是对于节点a，向上跳$2^x$次后的父节点。这体现了倍增二分的思想。 i从大到小遍历，遍历到了父节点不同就将a,b转移到这个不同的节点，然后继续向上遍历。通过二分法来降低算法复杂度。 ST表求LCA 如上图所示的树，使用DFS遍历$^*$，并对每个点进行编号，得到一下序列： A B D B E F E G E B A C A 1 2 3 2 3 4 3 4 3 2 1 2 1 $^*$ 不同于一般的DFS遍历，这里的DFS遍历需要记录回溯走过的顶点信息。 则可以得到以下性质：两个点首次出现位置中间这一段中深度最小（也就是值最小）的即为两点的LCA。 所以我们就可以把求LCA转换为求一段序列中的最小值 → 转换为使用ST表求一段的最小值。 所使用的DFS算法如下： 123456789101112131415int q[1000000];top = 0;void dfs(int u, int Fa){ q[++top] = u, sta[u] = top; for(int i = 1;i &lt;= 30;i++) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for(int i = head[u];i;i = e[i].next){ int to = e[i].to; if(to == Fa) continue; fa[to][0] = u; dfs(to, u); } q[++top] = u,end[u] = top;} 求LCA的具体算法如下： 1234567891011121314int lca(int a, int b){ int ans = INT_MAX; begin = 0; for (int i = 0; i &lt; top; i++){ if (q[i] == a || q[i] == b){ if(!begin) begin = 1; else break; } if (begin) ans = min(ans, q[i]); } return ans;}","link":"/2019/07/26/倍增/"},{"title":"算法学习：动态规划","text":"基本动态规划 动态规划 (Dynamic Programming) 是运筹学的一个分支，是求解决策过程最优化的数学方法。 ——摘自百度百科 以下内容学习自《算法图解》 实例背景： 假如有一个小偷，他的背包大小确定，假设为4磅。他有以下三件物品可以偷窃： 音响(S) 笔记本电脑(L) 吉他(G) 3000美元 2000美元 1500美元 4磅 3磅 1磅 为了让偷窃价值最高，他该偷窃哪些内容呢？ 方法一：枚举出每一种情况，然后比较每一种情况所能得到的货物的总价值。具体如下图所示： 当有3件物品时，我们需要罗列出8种情况。而当4件物品时就需要罗列16种情况；5件物品就需要32种情况，也就是说这样的求解方法的时间复杂度达到了$O(2^n)$。 方法二：动态规划 对于大的背包，我们可以先将其分解为一个个小的背包来考虑，最后用小的背包的情况来推知大的背包的最佳情况。 那么我们就会得到如下的一个表格： 类别 1 2 3 4 吉他 - - - - 音响 - - - - 笔记本电脑 - - - - 从左到右分别为1磅背包、2磅背包、3磅背包、4磅背包的情况，然后我们从第一行开始对表格进行填充： 吉他行 对于每一格，这个小偷都要考虑一个问题：“我到底要不要偷这个东西？” 对于第一个格，它的背包容量为1磅，所以我可以将吉他装下，所以他肯定是要偷的啦～ 于是表格就会更新成下面的这个样子： 类别 1 2 3 4 吉他 $1500 (G) - - - 音响 - - - - 笔记本电脑 - - - - 而对于之后的每个格，因为现在只有吉他可以偷，而这些包都可以放下吉他，所以我们就将这些格的内容更新如下： 类别 1 2 3 4 吉他 $1500 (G) $1500 (G) $1500 (G) $1500 (G) 音响 - - - - 笔记本电脑 - - - - 那这小偷既然可以直接推知四磅的情况，为什么还要记录1磅、2磅、3磅的情况呢？因为这些小问题将为解决后面的大问题作铺垫！😀 音响行 在第二行，我们可以偷的东西变成了吉他和音响，其上面一行记录了我们是否应该偷吉他以及已经获得了的价值最大值。那么我们结合它的上一行来判断是否需要偷音响。 对于第一格，无论怎样都装不下音响，所以继承了上一行的吉他的总价值，列表变成如下： 类别 1 2 3 4 吉他 $1500 (G) $1500 (G) $1500 (G) $1500 (G) 音响 $1500 (G) - - - 笔记本电脑 - - - - 相同的，2磅与3磅时也装不下音响（这音响居然这么大🌚），所以表格变成了： 类别 1 2 3 4 吉他 $1500 (G) $1500 (G) $1500 (G) $1500 (G) 音响 $1500 (G) $1500 (G) $1500 (G) - 笔记本电脑 - - - - 对于4磅时，音响可以装下了，那么他要不要偷这个音响呢？如果偷音响的话，那么我获得的价值将会是dp[0][0] + v[1]（dp[x][y]指列表中第x行第x列的元素（其中在上面的列表中第x列忽略，值全部为$0$），v[i]指第i件物品待偷物的价值），可得到值为 $ \\$ 3000$，如果不偷这个音响，则最后值为dp[0][4]，可到的值为 $\\$1500$，所以得出结论还是偷音响好。得到如下的列表： 类别 1 2 3 4 吉他 $1500 (G) $1500 (G) $1500 (G) $1500 (G) 音响 $1500 (G) $1500 (G) $1500 (G) $3000 (S) 笔记本电脑 - - - - 笔记本电脑行： 从音响一行已经可以了解到，有以下式子的成立：（$h[x]$ 指的是第 $x$ 可被偷物的质量/体积）$$dp[i][j] = \\max(dp[i - 1][j - h[x]]+v[x]\\ ,\\ dp[i - 1][j])$$所以根据这个公式，我们可以轻而易举的来填写笔记本电脑这一行，得到如下的列表： 类别 1 2 3 4 吉他 $1500 (G) $1500 (G) $1500 (G) $1500 (G) 音响 $1500 (G) $1500 (G) $1500 (G) $3000 (S) 笔记本电脑 $1500 (G) $1500 (G) $2000 (L) $3500 (G&amp;L) 举最后一格来解释：4磅的空间已经可以放下笔记本电脑，如果不偷笔记本电脑的话，我将得到dp[1][4]的价值，值为 $ \\$3000$。如果他偷笔记本电脑的话，我就可以获得dp[1][4 - 3] + v[2] = dp[1][1] + v[2]的价值，值为 $ \\$ 3500$。取更大的，我们就可以知道这一格应为 $ \\$ 3500$ 现在表格全部填写完毕了，最右下方的格子即为最终答案：$ \\$ 3500$。 再加一件商品又是如何呢？ 假如小偷现在又发现了一个新鲜玩意儿：iPhone！(I)（这东西这么贵肯定要偷的啊🤪） 那我们需要重新计算整个表格么？不需要！这也是动态规划的一大优点，我逐步计算出了前面的最大价值，那么再有新的元素出现，前面的数据依旧是可以用的！ 那么我们的列表多出一行，成为以下的样子： 类别 1 2 3 4 吉他 $1500 (G) $1500 (G) $1500 (G) $1500 (G) 音响 $1500 (G) $1500 (G) $1500 (G) $3000 (S) 笔记本电脑 $1500 (G) $1500 (G) $2000 (L) $3500 (G&amp;L) iPhone - - - - 从第一个格开始计算，这个iPhone太小了啊，1磅的空间就可以将它装下，所以此时第一个格就面临着要不要偷iPhone的抉择。如果不偷的话，就是dp[2][1]，值为 $ \\$ 1500$。如果偷，就是dp[2][1 - h(3)] + v[3] = dp[2][0] + v[3]，值为 $ \\$ 2000$。所以看来偷iPhone是个更好的选择！现在表格就成了： 类别 1 2 3 4 吉他 $1500 (G) $1500 (G) $1500 (G) $1500 (G) 音响 $1500 (G) $1500 (G) $1500 (G) $3000 (S) 笔记本电脑 $1500 (G) $1500 (G) $2000 (L) $3500 (G&amp;L) iPhone $2000 (I) - - - 依次以上面的方法对表格进行填充，最终表格成为： 类别 1 2 3 4 吉他 $1500 (G) $1500 (G) $1500 (G) $1500 (G) 音响 $1500 (G) $1500 (G) $1500 (G) $3000 (S) 笔记本电脑 $1500 (G) $1500 (G) $2000 (L) $3500 (G&amp;L) iPhone $2000 (I) $3500 (G&amp;I) $3500 (G&amp;I) $4000 (L&amp;I) 所以此时的最大值就变成了 $ \\$ 4000$，更多了呢！🤑 从以上内容可以看出，动态规划真的是一个神奇好用的算法呢！ 那么怎么敲它的代码呢？ C++： 12345678910111213141516171819202122232425int w[5] = {0, 1, 4, 3, 1}; // 每个物品的重量，w[0]无用int p[5] = {0, 1500, 3000, 2000, 2000}; // 每个物品的价值，p[0]无用int n = 4; // 物品的个数int m = 4; // 背包的载重量vector&lt;int&gt; x; // 用以记录所有的被装入背包的物品int v = 0;int dp[5][5]; // 注意多出一行一列int dp_funtion(){ for (int i = 0; i &lt; n + 1; i++){ for (int j = 0; j &lt; m + 1; j++){ if(j &gt;= w[i]) dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + p[i]); else dp[i][j] = dp[i - 1][j]; } } int j = m; for (int i = n; j &gt; 0; j++){ if (dp[i][j] &gt; dp[i - 1][j]){ x.push_back(i); j = j - w[i]; } } return dp[n][m];} Python： 1234567891011121314151617181920212223242526272829303132# 这里使用了图解中的吉他，音箱，电脑，手机做的测试，数据保持一致w = [0, 1, 4, 3, 1] #n个物体的重量(w[0]无用)p = [0, 1500, 3000, 2000, 2000] #n个物体的价值(p[0]无用)n = len(w) - 1 #计算n的个数m = 4 #背包的载重量x = [] #装入背包的物体，元素为True时，对应物体被装入(x[0]无用)v = 0#optp[i][j]表示在前i个物体中，能够装入载重量为j的背包中的物体的最大价值optp = [[0 for col in range(m + 1)] for raw in range(n + 1)]#optp 相当于做了一个n*m的全零矩阵的赶脚，n行为物件，m列为自背包载重量def knapsack_dynamic(w, p, n, m, x): #计算optp[i][j] for i in range(1, n + 1): # 物品一件件来 for j in range(1, m + 1): # j为子背包的载重量，寻找能够承载物品的子背包 if (j &gt;= w[i]): # 当物品的重量小于背包能够承受的载重量的时候，才考虑能不能放进去 optp[i][j] = max(optp[i - 1][j], optp[i - 1][j - w[i]] + p[i]) # optp[i - 1][j]是上一个单元的值， optp[i - 1][j - w[i]]为剩余空间的价值 else: optp[i][j] = optp[i - 1][j] #递推装入背包的物体,寻找跳变的地方，从最后结果开始逆推 j = m for i in range(n, 0, -1): if optp[i][j] &gt; optp[i - 1][j]: x.append(i) j = j - w[i] #返回最大价值，即表格中最后一行最后一列的值 v = optp[n][m] return v 区间DP区间DP就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的最优解进而得出整个大区间上的最优解的DP算法。 首先枚举区间长度len为每次分割成的小区间长度（由长到短不断合并），内层枚举该长度下的起点。然后在这个起点与中点之间枚举分割殿，求解这段小区间在某个分割点下的最优解。 123456789for(int len = 1; len &lt;= n; len++){//枚举长度 for(int j = 1; j + len &lt;= n+1; j++){//枚举起点，ends&lt;=n int ends = j + len - 1; for(int i = j; i &lt; ends; i++){//枚举分割点，更新小区间最优解 dp[j][ends] = min(dp[j][ends], dp[j][i] + dp[i+1][ends] + something); // something替换 } }}","link":"/2019/07/17/动态规划/"},{"title":"题解：洛谷P1955：[NOI2015]程序自动分析","text":"算法：并查基、离散化、文件读入与写出。 题目描述在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设 $x_1，x_2，x_3\\dots$代表程序中出现的变量，给定 $n$ 个形如$x_i=x_j$或$x_i \\neq x_j$的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$x_1=x_2,x_2=x_3,x_3=x_4,x_4\\neq x_1$，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入格式从文件prog.in中读入数据。 输入文件的第 $1$ 行包含 $1$ 个正整数 $t$，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第 $1$ 行包含 $1$ 个正整数 $n$ ，表示该问题中需要被满足的约束条件个数。接下来 $n$ 行，每行包括 $3$ 个整数 $i,j,e$，描述 $1$ 个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 $e=1$，则该约束条件为 $xi=xj$；若 $e=0$，则该约束条件为 $xi\\neq xj$； 输出格式输出到文件 prog.out 中。 输出文件包括 $t$ 行。 输出文件的第 $k$ 行输出一个字符串“ YES” 或者“NO”（不包含引号，字母全部大写），“YES” 表示输入中的第 $k$ 个问题判定为可以被满足，“NO” 表示不可被满足。 输入输出样例输入 #1 1234567221 2 11 2 021 2 12 1 1 输出 #1 12NOYES 输入 #2 12345678910231 2 12 3 13 1 141 2 12 3 13 4 11 4 0 输出 #2 12YESNO 说明/提示【样例解释1】 在第一个问题中，约束条件为：$x1=x2,x1\\neq x2$。这两个约束条件互相矛盾，因此不可被同时满足。 在第二个问题中，约束条件为：$x1=x2,x1=x2$。这两个约束条件是等价的，可以被同时满足。 【样例说明2】 在第一个问题中，约束条件有三个：$x1=x2,x2=x3,x3=x1$。只需赋值使得$x1=x1=x1$，即可同时满足所有的约束条件。 在第二个问题中，约束条件有四个：$x1=x2,x2=x3,x3=x4,x4\\neq x1$。由前三个约束条件可以推出$x1=x2=x3=x4$，然而最后一个约束条件却要求$x1\\neq x4$，因此不可被满足。 【数据范围】 【时限2s，内存512M】 题目传送门：🚪 文件读入与写出虽说题干写着从文件读入，写出到文件，但其实这个题完全不需要……直接标准读入读出就可以……可怜我太实诚……酿造了如下惨状： 既然提到了就说说这个…… C的方法 fopen()函数 使用方式：fp = fopen(&quot;input.in&quot;, &quot;r&quot;)： 第一个参数为打开文件的文件名； 第二个参数为文件方式，是文件的类型和操作要求，有如下几种（组合）： r：只读（read），要求文件必须已经存在； w：只写（Write），若文件不存在则自动创建，如果已存在则删除原文件后新建； a：追加（Append），保留文件中已有内容，从文件尾开始写； t：文本文件（Text），可忽略； b：二进制文件（Binary）； +：读写。 返回值为文件指针，为FILE类型的指针变量。 在具体使用此方法写入时，使用fscanf(fp, &quot;%d&quot;, &amp;n)来读取： 第一个参数为文件指针名，即使用fopen返回的指针； 第二个参数为格式控制符，同scanf()的使用方式； 第三及以后的参数为传入变量的指针。 使用fprintf(fp, &quot;%d\\n&quot;, n)来写入文件： 第一个参数为文件指针名，即使用fopen返回的指针； 第二个参数为格式控制符，同printf()的使用方式； 第三及以后的参数为输出变量。 结束使用该函数使用：fclose(fp) freopen()函数 使用方式：freopen(&quot;input.in&quot;, &quot;r&quot;, stdin);freopen(&quot;output.out&quot;, &quot;w&quot;, stdout);： 第一个参数为打开文件的文件名； 第二个参数为文件方式，同fopen()函数； 第三个参数为文件指针，通常使用标准流文件（stdin/stdout/stderr）。 使用freopen()函数，并使用了标准流文件后，就可以直接使用scanf()与printf()来读入和写出。 结束使用fclose(stdin);fclose(stdout)。 C++的方法123456ifstream inputFL(\"input.in\");ofstream outputFL(\"putput.out\");inputFL &gt;&gt; n;outputFL &lt;&lt; n &lt;&lt; endl;inputFL.close();outputFL.close(); 正式题解基本题意就是给你几个约束条件看他们能不能共存成立。而相等关系的约束条件我们可以很容易地想到将其转换为一个图，出现相等关系就说明它们在一个个图上 $\\Rightarrow$ 两个值的最终祖先节点相同。而出现不等关系就说明它们没在一个图上，所以这个问题就可以转换成一个并查集问题。在这里贴上并查基常用的板子： 得到最终祖先： 12345int get(int x){ if(x == fa[x]){ return x; }else return fa[x] = get(fa[x]);} 合并两棵树： 1234567void merge(int a, int b){ int faOa = get(a); int faOb = get(b); if(faOa != faOb){ fa[b] = a; }} 而注意到题目数据量很大，$i$、$j$ 的范围到了 $10^9$，无法开那么大的数组，所以我们使用到了离散化。我的离散化的博文的传送门：🚪 基本思想就是看输入的两个值是否相同，如果相同就保留到一棵树上。如果不相同的话检查两个点的根结点是否相同，如果相同则说明这两个值已经相同，出现矛盾，则输出“NO”。为了实现这个思想，我们首先要对输入进行排序，将相等关系放在前面预先判断。 AC代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define inputFL cin#define outputFL coutusing namespace std;struct Node{ int x; int y; bool e;}Nodes[100005];bool cmp(Node a, Node b){ return a.e &gt; b.e;}int dict[1000005];int fa[1000005];int cnt, uqcnt;int n;int get(int x){ if (x == fa[x]) { return x; }else return fa[x] = get(fa[x]);}// void merge(int x, int y){// fa[get(x)] = get(y);// }int main(){ // ifstream inputFL(\"prog.in\"); // C++方式， C使用freopen() // ofstream outputFL(\"prog.out\"); int T; inputFL &gt;&gt; T; while(T--){ inputFL &gt;&gt; n; memset(dict, 0, sizeof(dict)); memset(fa, 0, sizeof(fa)); uqcnt = cnt = 0; for (int i = 0; i &lt; n; i++) { inputFL &gt;&gt; Nodes[i].x &gt;&gt; Nodes[i].y &gt;&gt; Nodes[i].e; dict[cnt++] = Nodes[i].x; dict[cnt++] = Nodes[i].y; } sort(dict, dict + cnt); uqcnt = unique(dict, dict + cnt) - dict; for (int i = 0; i &lt; n; i++) { Nodes[i].x = lower_bound(dict, dict + uqcnt, Nodes[i].x) - dict; Nodes[i].y = lower_bound(dict, dict + uqcnt, Nodes[i].y) - dict; } for (int i = 0; i &lt; uqcnt; i++) { fa[i] = i; } bool check = 1; sort(Nodes, Nodes + n, cmp); for (int i = 0; i &lt; n; i++) { int a = get(Nodes[i].x); int b = get(Nodes[i].y); if (Nodes[i].e) { fa[a] = b; }else{ if (a == b) { check = 0; outputFL &lt;&lt; \"NO\" &lt;&lt; endl; break; } } } if (check) outputFL &lt;&lt; \"YES\" &lt;&lt; endl; }} 特别提醒：一定要分清离散化中各个变量的具体含义与用处，否则就会出现以下的状况而无从下手：","link":"/2019/07/30/P1955/"},{"title":"算法学习：后缀数组","text":"学习自： https://www.cnblogs.com/victorique/p/8480093.html#autoid-0-0-0 https://blog.csdn.net/Tiw_Air_Op1721/article/details/81275953?comment_content=%E6%8F%90%E9%86%92%E5%A1%AB%E5%9D%91&amp;comment_replyId=&amp;article_id=81275953&amp;comment_userId=&amp;commentId= 后缀数组简介后缀：从字符串某个位置 $i$ 到字符串末尾的子串，我们定义以字符串 $str$ 的第 $i$ 位为第一个元素的后缀为suff[i]。（后缀的英文：suffix） 后缀数组：把字符串 $str$ 的每一个后缀按照字典序排序后所形成的数组。 后缀数组的实现变量定义 suff[]数组，用来记录从第 $i$ 位开始的后缀 sa[]数组（suffix array），存储的是字典第 $i$ 小的后缀的下标。比如sa[0] = 8代表的是suff[]数组中第 $8$ 位后缀在字典序中最小。而suff(sa[0])才真正存储这最小的那个后缀的内容。 rank[]数组，与sa[]相反，存储的是下标为 $i$ 的后缀为第几小。一定存在关系 $\\text{rank}[\\text{sa}[i]] = i$。 倍增算法问题在于我们怎么给这个后缀数组排序，如果强硬 sort 的话，sort 算法复杂度本来就有 $O(n\\log_2n)$ 字符串排序还不用于一般数字的排序，每个字符串对比还有 $O(n)$ 复杂度。也就是说用 sort 的话，复杂度会达到 $O(n^2\\log_2n)$。这就很伤不是么，所以我们要想出来一个复杂度更低的算法。 我们知道，两个字符串的比较，如果前半部分相同则比较结果取决于后半部分的比较结果，否则只需要看前半部分的比较结果。基于这个事实，我们考虑以下方法： 对于字符串 $str$，定义k-前缀为： $$str_k=\\begin{cases}str[0\\dots k - 1] = str.\\mathrm{substr}(0, k) &amp; (k\\leq str.\\mathrm{length}()) \\\\str &amp; (k &gt; str.\\mathrm{length}())\\end{cases}$$然后类似的，我们定义出基于k-前缀意义下的sa[]数组和rank[]数组，在这里我们记作 $sa_k$ 与 $rank_k$ 数组。其中 $sa_k$ 为k-前缀意义下的后缀数组，$rank_k$ 为k-前缀意义下的名次数组。则有以下计算方式： 容易求出 $rank_1$ 的值与 $sa_1$ 的值，只需要进行 sort 对第一个字母排序就可以了。 得到了 $rank_k$，则定义二元组 $(rank_k[i],rank_k[i + k])$，按照“如果 $rank_k[i]$ 相同则比较$rank_k[i +k]$，否则则比较 $rank_k[i]$ ”的方法来进行sort，即可求出 $sa_{2k}$。 求出了 $sa_k$ 则可以很快求出 $rank_k$，有以下关系：$$rank_k[i] = \\begin{cases}rank_k[i - 1] &amp; suff[sa[i]]_k = suff[sa[i - 1]]_k \\\\rank_k[i - 1] + 1 &amp; suff[sa[i]] _ k \\neq suff[sa[i - 1]]_k\\end{cases}$$ 这样的话我们求解的顺序就是：$$sa_1 \\ \\&amp; \\ rank_1 \\rightarrow sa_2 \\rightarrow rank_2 \\rightarrow sa_4 \\rightarrow rank_4 \\rightarrow \\cdots \\rightarrow sa_n \\rightarrow rank_n$$当不再出现并列的 $rank$ 的时候就可以结束循环。整个过程如下图所示： 每一次排序需要进行 $n\\log_2n$ 次比较，每一次比较需要 $O(1)$ 复杂度，总共进行 $\\log_2n$ 次比较，因此总时间复杂度为$O(n\\log_2^2n)$。 基数排序这一部分我们要试图探索比 $O(n\\log _2^2n)$ 更优的排序算法。","link":"/2019/07/28/后缀数组/"},{"title":"算法学习：扩展KMP","text":"2019年8月5日下午，冰冷的雨滴击打着脆弱的窗户玻璃，机房里异常的安静，仿佛每个人都等待着一轮风暴。HDU的第五场多校赛已经过去了一半，距离吃饭只有两个半小时了，但我却没有一点开心的感觉。抬头，映入眼帘的就是一道魔鬼签到题目，和红色背景白色字体的“（-5）”字眼。机房的空调从来没有这么好使过，我甚至感到浑身寒冷，有几分想要颤抖身体。 比赛还是如期地结束了。这场比赛的这个签到题我还是没能做出来。是的，爆零了。我开始怀疑人生，怀疑自己存在的意义。挫败的我打开了题解，发现了这个叫做”扩展KMP“算法。虽然忧伤，但我还是尝试学习一下这个算法。于是…… 题解传送门：🚪 算法引入假设现在有两个字符串，分别为 $S$ 与 $T$ ，其中 $S$ 为待匹配的串，$T$ 为进行匹配的串，现在我需要知道 $S$ 的每一位开始，分别可以匹配成功 $T$ 串中从头开始的连续的多长子串。 举个例子，比如现在 $S$ 为字符串AAAAABBB， $T$ 为字符串AAAAAC。我们定义数组extend[]为最终结果，其中 $extend[i]$ 为 $S.\\mathrm{substr}(i,n)$ （$S[i \\cdots n-1]$） 中与 $T$ 匹配成功的最长相同前缀的长度。如本例中可得到如下表格： $i$ 0 1 2 3 4 5 6 7 $S$ A A A A A B B B extend[i] 5 4 3 2 1 0 0 0 如果使用暴力进行这个匹配过程的话，算法复杂度就达到了 $O(m\\times n)$，所以我们要用更好的算法来解决这个问题。这就是扩展 KMP 的任务。 算法思想我们为何引入并使用next[]数组暴力算法的问题就在于extend[]数组中的数据彼此之间是会有一些联系的，而暴力法并没有用上这些联系而直接进行了重新匹配。 假设我们现在匹配到了第 $i$ 个位置，如下图： 其中图中 $p$ 指从 $S$ 的第 $a$ 位开始与 $T$ 匹配成功的最后一位的下一位，也就是说 $S.\\mathrm{substr}(a,p) = T.\\mathrm{substr}(0,p-a)$。如果从 $i$ 开始的几位与 $T$ 开头的几位相同，那么 $extend[i]$ 的值就是这段距离的长度。所以我们引入 next[]数组来记录匹配串 $T$ 中相同前缀部分的长度。比如对于AAAAAC，我们就可以得到以下列表： $i$ 0 1 2 3 4 5 $T$ A A A A A C next[i] 6 4 3 2 1 0 从头开始遍历 $S$，设当前遍历到了第 $i$ 位，$i + next[i -a ]$ 的值会有以下几种情况： 注意：next[]数组 $i + next[i - a] &lt;p$ 说明这个时候的 $i + next[i-a]$ 还在可控范围内。因为我们已经知道了 $S.\\mathrm{substr}(a, p)$ 与 $T.\\mathrm{substr}(0, p-a)$ 相同，而 $S[i + next[i -a]]$ 还在 $S.\\mathrm{substr}(a, p)$ 的范围内，所以这个时候 $S.\\mathrm{substr}(i, i + next[i - a])$ 与 $T.\\mathrm{substr}(i - a, i - a + next[i - a])$ 就可以成立，于是 $S.\\mathrm{substr}(i, i + next[i - a])$ 与 $T.\\mathrm{substr}(0, next[i - a])$ 就会成立，所以我们就可以知道 $extend[i]$ 的值为 $next[i - a]$。 $i + next[i - a] = p$ 这种情况下，$S[p]$ 与 $T[p - a]$ 不一定相同，$T[p - i]$ 与 $T[p - a]$ 也不一定相同，但却有 $T[p - a]$ 与 $S[p]$ 相同的情况，所以我们就直接对比 $S[p]$ 与 $T[p - a]$ 及以后。然后得到 $next[i]$ 的值。当我最后匹配直到 $S[p + k]$ 与 $T[p+k-a]$ 相同，则可得到 $next[i]$ 的值为 $p + k - i$。下一次再匹配时，只需要从 $a = i$、$p = p + k$ 开始就可以了。 $i + next[i - a] &gt; p$ 这种情况下我们就不能确定这上面的匹配方式相同了，所以我们就需要从 $S[p]$ 与 $T[p - i]$ 开始匹配，具体做法同第 $2$ 种情况。 获得next[]数组其实这个就很简单了。next[]数组反映的即是 $T$ 字符串中从第 $i$ 位开始的内容与从第 $0$ 位内容开始的最大相同前缀，所以其实只是把 $T$ 与自己匹配跑了一编这个算法。 算法模板1234567891011121314151617181920212223242526272829303132333435363738int next[100];int extend[100];string S, T;void getNext(){ int m = T.length(); // m:T的长度 int a = 0, p = 0; next[0] = m; for (int i = 1; i &lt; m; i++) { if (i &gt;= p || i + next[i - a] &gt;= p) { if (i &gt;= p) p = i; while (p &lt; m &amp;&amp; T[p] == T[p - i]) p++; next[i] = p - i; a = i; } else next[i] = next[i - a]; }}void getExtend(){ int n = S.length(); int m = T.length(); int a = 0, p = 0; getNext(); for (int i = 0; i &lt; n;i ++){ if (i &gt;= p || i + next[i - a] &gt;= p) { // i &gt;= p 的作用：举个典型例子，S 和 T 无一字符相同 if (i &gt;= p) p = i; while (p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i]) p++; extend[i] = p - i; a = i; } else extend[i] = next[i - a]; }}","link":"/2019/08/06/扩展KMP/"},{"title":"算法学习：搜索","text":"深度优先搜索（DFS）DFS是一种使用栈结构的搜索方式，一般使用递归实现（因为递归就是在压栈嘛）。一般用于判断是否图是否连通或找到图的拓扑序来解决更多的图论问题，最基础使用DFS的问题就是迷宫问题。在进行搜索时，不断地向深处找下一个节点，如果没有下一个节点或下一个节点已经被访问的话，就回溯到有下一个节点可访问的点继续搜索。 如下图所示的图： 它的DFS遍历顺序为：$1 \\rightarrow 2 \\rightarrow 3\\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \\rightarrow 7 \\rightarrow 8 \\rightarrow 9$（这个真的只是巧了）。 有的时候还需要得到带有回溯的DFS序，如图就为：$1\\rightarrow 2\\rightarrow 3 \\rightarrow 4\\rightarrow 5\\rightarrow 4\\rightarrow 6\\rightarrow 7\\rightarrow 6\\rightarrow 8\\rightarrow 9\\rightarrow 8\\rightarrow 6\\rightarrow 4\\rightarrow 3\\rightarrow 2\\rightarrow 1$ 但DFS不仅仅只有搜索图那么简单还可以解决一些实际问题。如下题目（POJ 3900）： 一个劫匪带着一个可装 $m$ 重量的超大背包去抢银行，银行有 $n$ 个大箱子，第 $i$ 个箱子里有 $i$ 个重量为 $w_i$ ，价值为 $c_i$ 的大钻石，问该劫匪抢走钻石的最大价值。（一共有 $T$ 组数据） HINT$1\\leq T \\leq 74$； $1 \\leq n \\leq 15$； $1 \\leq m \\leq 1000000000\\ (10^9)$； $1 \\leq w_i, c_i \\leq 1000000000 \\ (10^9)$。 这道题看上去是一个01背包问题，但由于数据量巨大，无法开那么大的数组，所以只能使用DFS搜索。所以能够得到下面这段DFS代码： 123456789void dfs(int pos, long long nowcost, long long lastw){ // pos:搜索的位置 nowcost:当前抢走的总价值 lastw:背包剩余的空间 if (pos == n || lastw &lt;= 0) // 如果搜到了最后一个箱子或者没空间了 return; ans = max(ans, nowcost); for (int i = a[pos].num; i &gt;= 0; i--){ // 对每个箱子一个一个钻石的查 dfs(pos + 1, nowcost + i * a[pos].c, lastw - i * a[pos].w); }} 但这样太暴力了！TLE预定系列。所以我们要对我们的DFS进行一定的优化。 深度优先搜索的优化剪枝：对不满足条件的情况进行清除，减少算法所需要的时间，分为以下两种： 可行性剪枝：判断搜索能否得出答案，如果不能的话直接回溯。 最优性剪枝：又称为上下界剪枝，是一种重要的剪枝策略。它记录当前得到的最优值，如果当前节点已经无法产生比当前最优解更优的解时，可以提前回溯。 以上一个题目为示例，我们考虑它可能出现的剪枝方法： 在枚举时，如果出现了$w_{\\text{当前要去取的}} &gt; w_{\\text{背包剩余的}}$，则直接跳过： 1if (i * a[pos].w &gt; lastw) continue; 这是一种可行性剪枝。 在枚举时，如果$c_\\text{已经拿了的} + c_\\text{还没有拿的箱子的全部钻石} &lt; ans$，则不可能会出现更优解，所以回溯： 1if (nowcost + sum[pos] &lt; ans) return; 这是一种最优性剪枝。 在枚举时，设矿物的性价比为 $s$ ，$s_i = \\displaystyle\\frac{c_i}{w_i}$。如果 $w_\\text{背包剩余的} * s_\\text{还未偷的最大的} &lt; ans$，则不可能出现最优解，所以回溯。如果要石用这个剪枝的话，则要求在开始时就将这 $n$ 个箱子按照性价比从高到低进行排序，而 $n$ 的最大值也就只有 $15$ ，所以时间复杂度不高，完全可以满足要求。 1if (nowcost + (long long)ceil(a[pos].s * lastw) &lt; ans) return; 这是一种最优性剪枝。 另一个可以优化的搜索题目（POJ 1088）： 题目描述Michael 喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长底滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：$$\\begin{eqnarray}&amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\\\&amp; 16 &amp; 17 &amp; 18 &amp; 19 &amp; 6 \\\\&amp; 15 &amp; 24 &amp; 25 &amp; 20 &amp; 7\\\\&amp; 14 &amp; 23 &amp; 22 &amp; 21 &amp; 8 \\\\&amp; 13 &amp; 12 &amp; 11 &amp; 10 &amp; 9\\end{eqnarray}$$一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-…-3-2-1更长。事实上，这是最长的一条。 记忆化搜索：记录以前搜索所得到的结果，当我搜索其他位置而需要这个位置的值时，我就可以直接使用这个值而减少搜索时间。 如在这个题目中，每个点到最低点的最优解是一定的，所以我在遍历的过程中可以记住已经遍历出结果的点，这样就可以节省很多的时间。 123456789101112131415int dfs(int x, int y){ if (f[x][y] != 0) // 已经记录了这个点的结果 return f[x][y]; int maxt = 1; 用以计数 int t; // test 用以记录中间结果 for (int i = 0; i &lt; 4; i++){ // 上下左右四个点 int tx = x + dx[i], ty = y + dy[i]; // dx[] 与 dy[] 是用来记录得到四个点坐标的操作数组 if(tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= r &amp;&amp; ty &lt;= c &amp;&amp; hill[tx][ty] &gt; hill[x][y]){ t = dfs(tx, ty) + 1; maxt = max(t, maxt); } } f[x][y] = maxt; // 记忆化 return maxt;} 广度优先搜索（BFS）BFS是一种使用队列实现的搜索算法，每次搜索对一层的节点进行搜索，所以最后呈现出来的结果是一圈一圈地扩大，具体过程如下图所示（其中Q为当前的队列信息，标有阴影的边为BFS算法所走过的边）： 由于BFS是一层一层地进行搜索，所以BFS很适合进行搜索到一个点最少步数类型的搜索。 12345678910111213141516171819202122232425262728293031const int stepArr[4][2] = {{-1, 1, 0, 0}, {0, 0, -1, 0}}; // 方向数组：分别为上下左右移动int visited[x][y]; // 标记是否已经被访问struct Node{ int x; int y; int step; Node(int x1,int y1,int step1):x(x1),y(y1),step(step1){} // 生成节点的函数};Node node(0,0,0); // 生成一个节点queue&lt;Node&gt; q;int BFS(){ q.push(node); while(!q.empty()){ node = q.front(); q.pop(); if(node.x == n-1 &amp;&amp; node.y == n-1){ return node.step; } visit[node.x][node.y] = 1; for(int i=0; i &lt; 4; i++){ int x = node.x + stepArr[i][0]; int y = node.y + stepArr[i][1]; if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; visit[x][y] == 0 &amp;&amp; 其它条件 ){ visit[x][y] = 1; Node next(x,y,node.step+1); q.push(next); } } } return-1;} 广度优先搜索的优化 双向广搜：从初状态和末状态两端进行广搜，直到两区域开始重叠或者有公众节点结束 如果一个节点产生的系统呈二叉树式增长，那么对于扩展 $n$ 次的代价， 单向为 $2^n$，而双向则是 $2 * 2^\\frac{n}{2} = 2 ^{\\frac{n}{2} + 1}$ 利用散列表（Hash表）记录状态，避免遇到相同状态而增加搜索时间 如以下题目（洛谷P2730）： 题目背景在成功地发明了魔方之后，鲁比克先生发明了它的二维版本，称作魔板。这是一张有8个大小相同的格子的魔板：$$\\begin{eqnarray}&amp;1&amp;2&amp;3&amp;4 \\\\&amp;8&amp;7&amp;6&amp;5\\end{eqnarray}$$ 题目描述我们知道魔板的每一个方格都有一种颜色。这8种颜色用前8个正整数来表示。可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。对于上图的魔板状态，我们用序列（1，2，3，4，5，6，7，8）来表示。这是基本状态。 这里提供三种基本操作，分别用大写字母“A”，“B”，“C”来表示（可以通过这些操作改变魔板的状态）： “A”：交换上下两行； “B”：将最右边的一列插入最左边； “C”：魔板中央四格作顺时针旋转。 下面是对基本状态进行操作的示范： A:$$\\begin{eqnarray}&amp;8&amp;7&amp;6&amp;5 \\\\&amp;1&amp;2&amp;3&amp;4\\end{eqnarray}$$B:$$\\begin{eqnarray}&amp;4&amp;1&amp;2&amp;3 \\\\&amp;5&amp;8&amp;7&amp;6\\end{eqnarray}$$C:$$\\begin{eqnarray}&amp;1&amp;7&amp;2&amp;4 \\\\&amp;8&amp;6&amp;3&amp;5\\end{eqnarray}$$对于每种可能的状态，这三种基本操作都可以使用。 你要编程计算用最少的基本操作完成基本状态到目标状态的转换，输出基本操作序列。 A、B、C三种操作我们可以找到规则，写为函数来进行模拟，于是这样进行BFS。重点在于我们如何记录每一个状态。如果我们保留这8位数存储，使用一个8位的bool数组存储，判重时需要接近 $10^8$ 的布尔数组，空间接近200M，肯定超过限制。而我们最终需要的结果是操作的序列，所以我们不如使用操作序列来记录所有的状态。 所以有以下的AC代码（摘自洛谷巨佬getchar123）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;string a;#include&lt;bits/stdc++.h&gt;using namespace std;string a;map&lt;string,string&gt;m;queue&lt;string&gt;q;void A(string x){ string xx=x; for(int i=0;i&lt;4;i++){ char x1=x[i]; x[i]=x[7-i]; x[7-i]=x1; } if(m.count(x)==0){//没有出现过 q.push(x); m[x]=m[xx]+'A'; } return;}void B(string x){ string xx=x; x[0]=xx[3],x[1]=xx[0],x[2]=xx[1],x[3]=xx[2],x[4]=xx[5],x[5]=xx[6],x[6]=xx[7],x[7]=xx[4]; if(m.count(x)==0){ q.push(x); m[x]=m[xx]+'B'; } return;}void C(string x){ string xx=x; x[1]=xx[6],x[2]=xx[1],x[5]=xx[2],x[6]=xx[5]; if(m.count(x)==0){ q.push(x); m[x]=m[xx]+'C'; } return;}void bfs(){ q.push(\"12345678\"); m[\"12345678\"]=\"\"; while(q.empty()==false){ A(q.front()); B(q.front()); C(q.front()); if(m.count(a)!=0){//当出现目标序列 cout&lt;&lt;m[a].size()&lt;&lt;endl&lt;&lt;m[a]; return; } q.pop(); } return;}int main(){ for(int i=0;i&lt;8;i++){ char a1; cin&gt;&gt;a1; a+=a1; getchar(); } bfs(); return 0;}map&lt;string,string&gt;m;queue&lt;string&gt;q;void A(string x){ string xx=x; for(int i=0;i&lt;4;i++){ char x1=x[i]; x[i]=x[7-i]; x[7-i]=x1; } if(m.count(x)==0){//没有出现过 q.push(x); m[x]=m[xx]+'A'; } return;}void B(string x){ string xx=x; x[0]=xx[3],x[1]=xx[0],x[2]=xx[1],x[3]=xx[2],x[4]=xx[5],x[5]=xx[6],x[6]=xx[7],x[7]=xx[4]; if(m.count(x)==0){ q.push(x); m[x]=m[xx]+'B'; } return;}void C(string x){ string xx=x; x[1]=xx[6],x[2]=xx[1],x[5]=xx[2],x[6]=xx[5]; if(m.count(x)==0){ q.push(x); m[x]=m[xx]+'C'; } return;}void bfs(){ q.push(\"12345678\"); m[\"12345678\"]=\"\"; while(q.empty()==false){ A(q.front()); B(q.front()); C(q.front()); if(m.count(a)!=0){//当出现目标序列 cout&lt;&lt;m[a].size()&lt;&lt;endl&lt;&lt;m[a]; return; } q.pop(); } return;}int main(){ for(int i=0;i&lt;8;i++){ char a1; cin&gt;&gt;a1; a+=a1; getchar(); } bfs(); return 0;} A*算法（看到这里请提醒博主填完这里或者删掉）","link":"/2019/07/19/搜索/"},{"title":"算法学习：尺取法","text":"假设给你一个数组与一个整数，要求你的到这个数组中的一个子区间使其的区间和等于这个整数，你会怎么做呢。可能首先想到的就是开一个双重循环，然后每一次都求一次和，然后和给定的数进行比较： 12345678910111213141516int sum;int ansi, ansj;for(int i = 0; i &lt; n; i++){ for(int j = i + 1; j &lt; n; j++){ sum = 0; for(int k = i; k &lt;= j; k++){ sum += ls[k]; } if(sum == x){ ansi = i; ansj = j; goto ans; } }}ans:printf(\"%d %d\\n\", ansi, ansj); 这样的话，复杂度就会到达 $O(n^2)$。 尺取法的算法思想来源于以上那个算法，区别在于不再对前后指针进行疯狂枚举，也不再需要每次都进行一次求和。我们设置两个指针，起初都指向开头。然后如果区间的元素和小于给定的数，则将右指针右移。如果大于指定的数，则将区间的左指针右移。相同就出结果了。这样的话每次求和只需要加上或减去那个唯一一个有区别的元素。复杂度会降低到 $O(n)$。 如下习题（POJ 3016）： DescriptionA sequence of $N$ positive integers $(10 &lt; N &lt; 100000)$, each of them less than or equal $10000$, and a positive integer $S(S &lt; 100000000)$ are given. Write a program to find the minimal length of the subsequence of consecutive elements of the sequence, the sum of which is greater than or equal to $S$. InputThe first line is the number of test cases. For each test case the program has to read the numbers $N$ and $S$, separated by an interval, from the first line. The numbers of the sequence are given in the second line of the test case, separated by intervals. The input will finish with the end of file. OutputFor each the case the program has to print the result on separate line of the output file. if no answer, print $0$. Sample Input12345210 155 1 3 5 10 7 4 9 2 85 111 2 3 4 5 Sample Output1223 AC代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;climits&gt;using namespace std;int lis[100005];long long sum;int min(int a, int b){ if(a &gt; b) return b; else return a;}int main(){ int T; scanf(\"%d\", &amp;T); while(T--){ int N, S; scanf(\"%d %d\", &amp;N, &amp;S); for (size_t i = 0; i &lt; (size_t)N; i++) { scanf(\"%d\", &amp;lis[i]); } int left = 0, right = 0; sum = lis[0]; int ans = INT_MAX; while(left &lt;= right &amp;&amp; right &lt; N){ if(sum &lt; S){ right++; sum += lis[right]; }else if(sum &gt;= S){ ans = min(ans, right - left + 1); sum -= lis[left]; left++; } }&gt; if(ans != INT_MAX) printf(\"%d\\n\", ans); else printf(\"0\\n\"); }}","link":"/2019/07/27/尺取法/"},{"title":"算法学习：马拉车算法","text":"学习自博客： https://www.cnblogs.com/love-yh/p/7072161.html https://blog.csdn.net/happyrocking/article/details/82622881 马拉车算法（音译，Manacher’s algorithm）是一个复杂度为 $O(n)$ 的、求一个字符串最长回文子序列的算法。 回文字符串，就是指无论从左向右读还是从右向左读结果都是一样的字符串。如字符串google的最长回文字串为goog。 极限暴力的求得字符串最长回文字序列的方法都是寻找每个中心点开始向两边扩延一位一位地看是否相同，这样的算法复杂度回到 $O(n^2)$，显然不满足一般的需求。且由于回文字符串长度的奇偶问题，还需要特别的奇偶分类问题：如回文字符串aba的中心是b这个字母，回文字符串abba的中心是两个b之间。这两种情况需要分别考虑。 马拉车算法思想去除字符串长度奇偶分类的问题马拉车首先在每两个字符之间（包括首尾两端）插入一个原字符串没有的特殊符号，比如#。假设我们现在的字符串为google，插入#后便转换为了：#g#o#o#g#l#e#。设字符串长度为 $len$，加入的特殊字符个数一定为 $len + 1$，而 $len$ 与 $len + 1$ 中必为一奇一偶，所以结果一定是一个奇数，这样的话部分回文字符串（如#g#o#o#g#）的中心一定会是一个字符而不是两字符中间。 半径数组设原来的字符串为 $str$，加上特殊字符处理后的字符串为$strM$。为了记录每一位对应的最长回文字串半径，我们引入与 $strM$ 半径数组 $p[]$，其中 $p[i]$ 表示以 $strM[i]$ 为中心的最长回文字串的半径，如果 $p[i] = 1$ 就说明该回文串就是 $strM[i]$ 本身。如例子#g#o#o#g#l#e#，可得到如下表格： $i$ 0 1 2 3 4 5 6 7 8 9 10 11 12 $strM[i]$ # g # o # o # g # l # e # $p[i]$ 1 2 1 2 5 2 1 2 1 2 1 2 1 可以观察到，$p[i] - 1$ 就是以第 $i$ 位为中心的回文字串在原字符串中的长度。假设在原字符串中，该回文字符串的长度 $l$，由于加入了 $l+ 1$ 个#，在新字符串中的长度就会变为 $ln = 2 \\times l + 1$。而 $p[i]$ 存储的是新的字符串的回文字串的半径，也就是 $\\frac{ln + 1}{2}$ $=$ $l + 1$，即 $p[i] = l + 1$，所以最终结果为 $p[i] - 1$。 由于字符串的最开始与最后都有一个#字符，为了在搜索回文字串时避免总是判断是否越界，我们在字符串的左端与右端都加上另外一个特殊字符，如$与^。（其实最后一位处不需要加上这个特殊字符，因为字符串的最后本来就是有一位\\0用以标记字符串的结束的。） 所以这个算法的重点就在于如何计算数组 $p[]$ 的值。 $p[]$ 数组求解引入两个变量，分别为id与mx。其中id为一个已经检查过了的最大的回文字符串的中心点，mx为这个回文字符串的最终点。在马拉车算法的过程中，我们不断的对这两个变量进行更新。在这个过程中，我们有公式：$$p[i] = \\min(mx - i, p[2\\times id - i])$$现在我们就重点来讲解这个公式，如下图所示（其中 $j$ 是 $i$ 关于 $id$ 的对称点（$j = 2\\times id - i$），蓝色串➀为以 $j$ 为中心的回文串，橙色串为以 $i$ 为中心的回文串，绿色串为以 $id$ 为中心的回文串）： 目前我们已经求得了满足 $0 \\leq x \\leq i - 1$ 的 $p[x]$，接下来就是要使用以前的数据推得 $p[i]$。会有如下情况 $i \\leq mx$ 由于 $j$ 与 $i$ 关于 $id$ 对称，所以以 $j$ 为中心的回文串关于 $id$ 对称一下就成了以 $i$ 为中心的回文串。所以我们这个时候需要判断一下情况： 如果橙色串的末尾没有超过 $mx$， 即 $p[j] \\leq mx - i$，此时 $p[i] = p[j]$。 如果橙色串的末尾超过了$mx$，即 $p[j] &gt; mx - i$，此时就不能确定 $p[i] = p[j]$ 一定会成立了。则先赋值 $p[i] = mx - i$ ，然后手动向两边扩来得到最长回文子串。为什么 $p[j] = mx -i + 1$ 的情况归到了这里？因为当 $p[j] = mx -i + 1$，我们的回文子串直接定到了 $mx$ 上，我们不能确定 $mx$ 以后的位是否还能满足关于 $i$ 回文。 $i &gt; mx$ 那我们只能保证 $mx - i $ 这一段是满足的，所以我们就先让 $p[i] = mx -i$，其余部分使用笨方法慢慢扩张。 有没有可能橙色串的左端超过了 $mx$ 的对称点呢？不可能。如果说左端超过了 $mx$ 的对称点，且中心位于 $i$ 的话，则 $i$ 为中心的回文字串长度会超过以 $id$ 为中心的回文字串，也就是说以 $j$ 为中心的回文子串长度超过了 $id$ 为中心的回文字串，那么我的 $id$ 在之前应该被更新为 $j$。所以这种情况是不存在的。 算法模板12345678910111213141516171819202122232425262728293031323334string Manacher(string str){ /*改造字符串*/ string res=\"$#\"; for(int i=0; i &lt; (int)str.length(); ++i) { res += str[i]; res += \"#\"; } /*数组*/ vector&lt;int&gt; p(res.length(), 0); int mi = 0, right = 0; //mi为最大回文串对应的中心点，right为该回文串能达到的最右端的值 int maxLen = 0, maxPoint = 0; //maxLen为最大回文串的长度，maxPoint为记录中心点 for (int i = 1; i &lt; res.length(); ++i){ p[i] = (right &gt; i)? min(p[2 * mi - i], right - i) : 1; //关键句，文中对这句以详细讲解 while(res[i + p[i]] == res[i - p[i]]) ++p[i]; if(right &lt; i + p[i]) //超过之前的最右端，则改变中心点和对应的最右端 { right = i + p[i]; mi = i; } if(maxLen &lt; p[i]) //更新最大回文串的长度，并记下此时的点 { maxLen = p[i]; maxPoint = i; } } return str.substr((maxPoint - maxLen) / 2, maxLen - 1);}","link":"/2019/08/14/马拉车算法/"},{"title":"算法学习：离散化","text":"Banner 图源网络，侵删。 离散化离散化：将无限空间中的有限个体映射到有限的空间中。 比如说我有一个无尽的坐标轴，上面有 $10^4$ 个点，每个点的坐标值可以很大很大接近无限。如果我想知道比其中一个点小的点有多少个，暴力比较每个点的坐标值则会因为数据过大而 Boom。而我们通过点与点相对关系，将点的值进行重新赋值，则可以大大减小算法的复杂度。 比如，我现在的数轴上只有6个点， 他们的坐标分别为 $0$、$610$、$10^5+2$、$99$、$5$、$10^9+45$，如果我只是按照他们原有的值进行比较，最大要比较到 $10^9+45$。而如果我们用他们的相对大小来进行比较，即转换为 $0$、$3$、$4$、$2$、$1$、$5$ 则会方便很多。这就是离散化的思想，就是将离散的事物进行重新分配。 离散化方法：排序+二分（推荐使用本方法） 基本原理就是排序后使用STL中的unque()函数来获取整体数据不同元素的个数，然后在已排序序列二分查找 $num[i]$ 的值，从而得到对 $num[i]$ 对应的值，然后进行重新赋值。 12345678for(int i = 0; i &lt; n; i++){ scanf(\"%d\", &amp;num[i]); disc[i] = num[i]; // num:原数据数组，disc:离散化后的数组}sort(disc, disc + n);cnt = unique(disc, disc + n) - disc; // STL中的unique函数，具体内容见👇for(int i = 0; i &lt; n; i++) num[i] = lower_bound(disc, disc + n, num[i]) - disc; unique(a, b)函数：STL中比较常见的函数，他的功能是“删除”序列中所有相邻的重复元素（只保留一个），因为只是处理相邻的重复元素所以在使用这个函数之前要进行排序。（此处略去更具体的都能再写一页博客的内容）。其中参数a,b为指针，类似sort()函数中的参数。 lower_bound(a, b, v)函数：二分查找返回a、b指针之间空间中大于等于 $v$ 的第一个迭代器。 离散化方法：排序+暴力12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define MAX_N 1e5+5 // 根据实际问题调整struct Node{ int data; int index;}num[MAX_N];bool cmp(Node a, Node b){ return a.data &lt; b.data;}int rank[MAX_N], n;int main(){ scanf(\"%d\", &amp;n); for(int i = 0;i &lt; n; i++){ scanf(\"%d\", &amp;num[i].data); num[i].index = i; } sort(num, num + n, cmp); for(int i = 1; i &lt;= n; i++){ rank[num[i].id] = i; } return 0;} 排序之后按照原顺序进行赋值，相同元素就会出现离散化不成同一元素的情况，所以不推荐这种方法。 听大佬说洛谷P1955是一道有关离散化的题，我这个蒟蒻还没有做。🙃 有时间做了再搞题解什么的。🙃 题解我搞出来了，传送门：🚪","link":"/2019/07/30/离散化/"},{"title":"算法学习：基础数据结构","text":"单调队列、树状数组、差分队列与线段树。 单调队列一个具有单调性的队列，具体操作为：（单调增的队列） 若队列为空，将A[i]从对队尾入队。 若队列不为空，将比A[i]大的元素从队尾弹出，然后把A[i]入队。 若队列不为空且A[i]大于队尾，则直接从队尾把A[i]入队。 树状数组 以前的板子有，先略过（注意提醒博主补上） 差分队列（区间修改点查询的树状数组）树状数组本身是点修改区间查询的，对于原本的模式他有两个数组：a[]，用以记录原本的数组序列；b[]用以记录形成的树状数组。 将这两个数组角色翻转，用b[]来表示原本的、要被修改的数组，用a[]记录辅助的，用以查询的数组。则按以下方法构建： 有已知数组a[]，用以记录原数组值。 引入差分数组b[]，定义$b[i] = a[i] - a[i-1]$。可以得到 $a[i] = b[1] + b[2] + b[3] + \\cdots+b[i] $。 引入树状数组a[]维护b[]的前缀和。 由以上关系，当我需要对a[]的区间 $[l,r]$ 进行修改，全部加上k值，只需要将b[l] += k，b[r + 1]-= k即可实现。Update后对a[i]具体值直接进行点查询。 二维树状数组123456789101112131415161718int s[105][105],N,M;int lowbit(int i){ return i &amp; -i;}void set(int i, int j, int x){ for (int ii = i;ii &lt;= N;ii+= lowbit(ii)){ for(int jj = j;j &lt;= M;jj += lowbit(jj)){ s[ii][jj] += x; } }}int get(int i, int j){ int ans = 0; for (int ii = i;ii &gt; 0;ii -= lowbit(ii)) for(int jj = j;jj &gt; 0;jj -= lowbit(jj)) ans += a[ii][jj]; return ans;} 线段树 线段树是一种如上图所示的数据结构，将一个长度较长的数组按照树的结构不断二分形成如图结构。 线段树的解题关键： 如何通过子节点来推出父节点的信息？每一个节点都需要哪些信息？ 在区间更新中，我如何通过父节点的增值内容推出子节点的增值内容以便在进行区间查询时得到正确的结果？(Lazy Tag 的设定) 线段树的存储结构： 建立数组tree[]，数组下标从1开始，其中tree[1]为根节点，整体的统计信息、最终答案都将会存在tree[1]中。 对于任意一个节点tree[x]，它的左节点信息存储在tree[2 * x]中，右节点信息存储在tree[2 * x + 1]中。 线段树的操作函数： build()函数：用于建立整个线段树。 通过递归不断将二分分解原区间，直到找到叶节点所在位置（长度为1的区间） 将具体值放在这个叶节点，然后不断向上回溯修改所有父节点的值。 12345678910111213141516void build(int l, int r, int root){ if(l == r){ num[root] = 1; return; } // [l, mid]:左子树 [mid+1, r]:右子树 int mid = (l + r) / 2; build(l, mid, root*2); build(mid+1, r, root*2 + 1); push_up(root); // 对于这个根节点，先把左右子树都算出来了，再来更新它的值。 // 沿路回溯。回溯到的点root，都是被[la, rb]或其子区间影响到的点，边回溯边更新。}// 调用 build(1, N, 1); update()函数：修改（更新）函数，分为单点更新和区间更新。 单点更新的update()函数： 由根节点 $1$ 向下递归，找到对应的叶节点； 修改叶结点的值； 向上返回，在函数返回的过程中，更新路径上的节点的统计信息。 123456789101112131415void upgrade(int p, int val, int l, int r, int root){ // 单点更新，值增加增加val if (l == r){ num[root] += val; return; } int mid = (l + r) / 2; if (p &gt; mid) // 如果p &gt; 当前区间的中点， 说明我想找的[p, p]区间，在右半边 upgrade(p, val, mid+1, r, root * 2 + 1); else upgrade(p, val, l , mid, root * 2); //沿路返回，回溯到的点root， 都是被[p, p]区间影响到的点，边回溯边更新 num[root] = num[root * 2] + num[root * 2 + 1];} 区间更新的update()函数： 与单点更新的区别在于，区间修改在理论上是需要向下修改的（因为父区间变化，子区间也会变化） 为减少操作的复杂度，引入lazy_tag，这样我们暂时不更新下面的子节点，而是在需要用到子节点的时候再顺着这个标签向下更新子节点（需要用到push_down()函数） 123456789101112131415161718192021222324void update(int la, int rb, int l, int r, int val, int root){ /* la、lb为需要更新的区间的左端点（不发生变化） l、r为当前区间的左、右端点（会随着递归而发生更新） root为当前[l, r]对应的根存储位置（随递归更新） 更改区间内值为val */ // 如果本次所看的区间，整个就包含在所要查询的区间内。 if(la &lt;= l &amp;&amp; rb &gt;= r){ num[root] = (r - l + 1) * val; // 把本区间的num更新为正确值 lazy[root] = val; // 增加lazy标记，表示本区间的Sum正确，子区间的Sum 任然需要根据lazy的值来调整。 return; } push_down(root, r - l + 1); //继续递归前，先将当前root的标记向下传，从而保证再计算root时，他的左右两个自述都已经是正确的值，左右两个子树都不存在lazy更新延迟，都已经更新好了。 int mid = (l + r) / 2; if (la &lt;= mid){ update(la, rb, l, mid, val, root * 2); } if (rb &gt; mid){ update(la, rb, mid + 1, r, val, root * 2 + 1); } push_up(root);} push_up()函数：父节点回溯更新函数 这个函数的目的是，已经知道了两个子节点的信息，利用这个函数推出父节点的信息。 前提是两个节点的信息已经是正确了的、更新过了的。 123void push_up(int root){ num[root] = num[root * 2] + num[root * 2 + 1];} push_down()函数：区间更新，将lazy_tag向下推。 更新左右节点的 Lazy 值，也就是：把父节点root上面的 Lazy 标记，下推到两个子节点上 依据 Lazy Tag 的定义，更新左右节点的num值，使左右子节点的值成为被更新过的、正确的值。 把父节点的 Lazy Tag 值清空。因为 Lazy Tag 已经下推，就向上查询来看，父节点自身的 Lazy Tag 已经不再需要。 1234567891011void push_down(int root, int len){ if (lazy[root] == 0) return; lazy[root * 2] = lazy[root]; lazy[root * 2 + 1] = lazy[root]; num[root * 2] = lazy[root * 2] * (len - (len) / 2); num[root * 2 + 1] = lazy[root * 2 + 1] * ((len) / 2); lazy[root] = 0;}","link":"/2019/07/17/某些数据结构（树状数组、差分对列、线段树）/"},{"title":"算法学习：线性基","text":"线性基 ——异或和求最大值 学习自博客：https://blog.sengxian.com/algorithms/linear-basis 基（basis）是线性代数中的一个概念，他是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素被称为基向量。向量空间中的任意一个元素，都可以唯一地被表示成基向量的线性组合。异或空间基向量，被称为线性基。 从线性代数开始的异或世界线性空间（向量空间）定义$({\\Bbb F},\\mathrm V,+,\\cdot)$为线性空间（Vector Space）。其中 $\\Bbb F$ 为域，其中的元素为标量；$\\mathrm V$ 为集合，其中的元素称为向量，有以下两个运算： 向量加法：$\\mathrm V+\\mathrm V\\rightarrow \\mathrm V$，记作 ${\\bf v}+{\\bf w},\\exists {\\bf v},{\\bf m} \\in \\mathrm V$； 标量乘法：${\\Bbb F}\\cdot \\mathrm V\\rightarrow \\mathrm V$，记作 $a \\cdot {\\bf v}, \\ \\exists {\\bf a} \\in {\\Bbb F},{\\bf v}\\in \\mit \\mathrm V$ 且运算满足以下公理： 向量加法结合律：${\\bf u} + ({\\bf v} + {\\bf w}) = ({\\bf u} + {\\bf v} ) + {\\bf w}$； 向量加法交换律：${\\bf v} + {\\bf w} = {\\bf w} + {\\bf v}$； 向量加法的单位元：$\\mathrm V$ 中有一个被称为零向量的 $\\bf 0$，$\\forall {\\bf v}\\in \\mathrm V$，${\\bf v} + {\\bf 0} = {\\bf v}$； 向量加法的逆元素：$\\forall {\\bf v}\\in \\mathrm {V}$，$\\exists {\\bf w} \\in \\mathrm V$，使得${\\bf v} + {\\bf w} = 0$，其中 ${\\bf w}$ 称为 ${\\bf v}$ 的逆元； 标量乘法与标量的域乘法相容：$a(b{\\bf v} ) = (ab){\\bf v}$； 标量乘法的单位元：域$\\Bbb F$存在乘法单位元 $1$ 满足 $1{\\bf v} = {\\bf v}$； 标量乘法对向量加法的分配律：$a({\\bf u} + {\\bf v}) = a{\\bf u} + a{\\bf v}$； 标量乘法对域加法的分配律：$(a+b){\\bf v} = a{\\bf v} + b{\\bf v}$。 基本性质： 零元素 $0$ 是唯一的； 对任意的$a\\in {\\Bbb F}$，$a \\cdot {\\bf 0} = {\\bf 0}$； 对任意的${\\bf u}\\in \\mathrm V$，${\\bf 0}\\cdot{\\bf u} = {\\bf 0}$（ ${\\bf 0}$ 是 $\\Bbb F$ 的加法单位元）； 如果 $a \\cdot {\\bf u} = {\\bf 0}$，则要么 $a = 0$ ，要么 ${\\bf u} = {\\bf 0}$； 向量加法的逆向量 $\\bf v$ 是唯一的，记作$-\\bf v$。${\\bf u} + {- \\bf v}$ 也可以写成 ${\\bf u} - \\bf v$，两者都是标准的； 对 $\\forall {\\bf u} \\in \\mathrm V$， $-1\\cdot {\\bf u}=-{\\bf u}$。 对 $\\forall a\\in \\Bbb F$ 以及${\\bf u}\\in V$，$(-a)\\cdot {\\bf u} = -(a\\cdot {\\bf u}) = a \\cdot (-{\\bf u})$。 其他扩展内容： 最为常见的向量空间的例子是给定了直角坐标系的平面：平面上的每一点 $P$ 都有一个坐标 $P(x,y)$ ，并对应着一个向量 $(x,y)$。所有普通意义上的平面向量组成了一个空间，记作 $\\Bbb R^2$（因为每个向量都可以表示为两个实数构成的有序数组$(x,y)$。可以验证，对于普通意义上的向量加法和标量乘法，$\\Bbb R^2$ 满足向量空间的所有公理。设所有普通意义上的平面向量记作 $\\mathrm V$ ，则 ${\\Bbb R}^2 = ({\\Bbb R}, \\mathrm V,+,\\cdot)$。实际上，向量空间是 $\\Bbb R^2$ 的推广。 对于通常意义上的多项式加法和标量乘法，所有系数为实数的多项式的集合 $\\Bbb R[\\bf X]$ 也构成一个向量空间。更广泛的，所有从实数域射到实数域的连续函数的集合 $\\mathcal C(\\mathbb R,\\mathbb R)$也是向量空间 线性无关对向量空间中 $\\mathrm V$ 上的 $n$ 个元素的向量组 $({\\bf v}_1,\\dots,{\\bf v}_n)$，若存在不全为 $0$ 的数 $a_i\\in \\mathbb F$，满足：$$a_1{\\bf v}_1 + a_2{\\bf v_2} + \\dots + a_n{\\bf v} _ n = 0$$则称 $n$ 个向量线性相关（Linearly Dependent），否则称为线性无关（Linearly Independent）。 线性组合对于向量空间中 $\\mathrm V$ 上 $n$ 个元素的向量组 $({\\bf v}_1,\\dots,{\\bf v}_n)$，其线性组合（Linear Combination）是如下形式的向量：$$a_1{\\bf v_1} + a_2{\\bf v}_2 + \\dots+a_n{\\bf v}_n$$其中 $a_1,\\dots,a_n\\in \\mathbb F$。 张成（Span）对于相连空间中 $V$ 上 $n$ 个元素的向量组 $({\\bf v}_1,\\dots,{\\bf v}_n)$，其所有线性组合所构成的集合称为 $({\\bf v}_1,\\dots,{\\bf v}_n)$ 的张成（Span），记作$\\mathrm{span}(\\mathbf{v}_1, \\ldots, \\mathbf{v}_n)$。 基（Basis)基（Basis）（也称为基底）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为基向量。向量空间中任意一个元素，都可以唯一地表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。 给定一个向量空间 ${\\displaystyle \\mathrm {V}}$。${\\displaystyle \\mathrm {V}}$ 的一组基 ${\\displaystyle {\\mathfrak {B}}}$ 是指 ${\\displaystyle \\mathrm {V} }$ 里面的可线性生成 ${\\displaystyle \\mathrm {V} }$ 的一个线性无关子集。${\\displaystyle {\\mathfrak {B}}}$ 的元素称为基向量。 更详细来说，设 ${\\displaystyle {\\mathfrak {B}}={\\mathbf e_{1},\\mathbf e_{2},\\cdots ,\\mathbf e_{n}}}$ 是在系数域 ${\\displaystyle \\mathbb {F}}$（比如实数域 ${\\displaystyle \\mathbb {R}}$ 或复数域${\\displaystyle \\mathbb {C}}$）上的向量空间 ${\\displaystyle \\mathrm {V}}$ 的有限子集。如果 ${\\displaystyle {\\mathfrak {B}}}$ 满足下列条件： 对任意 ${\\displaystyle (\\lambda_{1},\\lambda_{2},\\cdots ,\\lambda_{n})\\in \\mathbb {F} ^{n}}$ ，如果 ${\\displaystyle \\lambda_{1}\\mathbf e_{1}+\\lambda_{2}\\mathbf e_{2}+\\cdots +\\lambda_{n}\\mathbf e_{n}=0}$ 则必然 ${\\displaystyle \\lambda _{1}=\\lambda _{2}=\\cdots =\\lambda _{n}=0}$； 对任意 ${\\displaystyle \\mathbf v\\in \\mathrm {V} }$，可以选择 ${\\displaystyle (\\lambda_{1},\\lambda_{2},\\cdots ,\\lambda_{n})\\in \\mathbb {F} ^{n}}$，使得 ${\\displaystyle v=\\lambda_{1}\\mathbf e_{1}+\\lambda_{2}\\mathbf e_{2}+\\cdots +\\lambda_{n}\\mathbf e_{n}}$。 就说 ${\\displaystyle {\\mathfrak {B}}}$ 是向量空间 ${\\displaystyle \\mathrm {V} }$ 的一组基。 性质： 设 $\\mathfrak {B}$ 是向量空间 $\\mathrm V$ 的基。则 $\\mathfrak {B}$ 具有以下性质： $\\mathrm V$ 是 $\\mathfrak {B}$ 的极小生成集，就是说只有 $\\mathfrak {B}$ 能张成 $\\mathrm V$，而它的任何真子集都不张成全部的向量空间。 $\\mathfrak {B}$ 是 $\\mathrm V$ 中线性无关向量的极大集合，就是说 $\\mathfrak {B}$ 在 $\\mathrm V$ 中是线性无关集合，而且 $\\mathrm V$ 中没有其他线性无关集合包含它作为真子集。 $\\mathrm V$中所有的向量都可以按唯一的方式表达为 $\\mathfrak {B}$ 中向量的线性组合。 第三点尤其重要，感性的理解，基就是向量空间中的一个子集，它可以通过唯一的线性组合，来张成向量空间中所有的向量，这样就可以大大的缩小我们向量空间的大小。 线性相关性引理（Linear Dependent Lemma）如果 $(\\mathbf{v}_1, \\ldots, \\mathbf{v}_n)$ 在 $\\mathrm V$ 中是线性相关的，并且 $\\mathbf{v}_1 \\neq 0$，则有至少一个 $j \\in {2, \\ldots, m}$使得下列成立： $\\mathbf{v}_j \\in \\mathrm{span}(\\mathbf{v}_1, \\ldots, \\mathbf{v}_{j - 1})$； 如果从$ (\\mathbf{v}_1, \\ldots, \\mathbf{v}_n)$ 去掉第 $j$ 项，则剩余向量组的张成仍然等于 $\\mathrm{span}(\\mathbf{v}_1, \\ldots, \\mathbf{v_n})$。 证明： 设 $(\\mathbf{v}_1, \\ldots, \\mathbf{v}_n)$在 $\\mathrm V$ 中是线性相关的，并且 $\\mathbf{v}_1 \\neq \\mathbf{0}$，则有不全为 $0$ 的 $a_1, \\ldots, a_n \\in \\mathbb F$，使得$$a_1\\mathbf{v}_1 + \\ldots + a_m\\mathbf{v}_m = \\mathbf{0}$$$a_2, a_3, \\ldots, a_n$不会全为 $0$（因为 $\\mathbf{v}_1 \\neq \\mathbf{0}$）。设 $j$ 是 ${2, \\ldots, m}$ 中使得 $a_j \\neq 0$ 的最大者，那么$$\\mathbf{v}_j = -\\frac {a_1} {a_j}\\mathbf{v}_1 - \\ldots - \\frac {a_{j - 1}} {a_j}\\mathbf{v}_{j - 1}$$这就有 $(1)$ 成立。 为了证明 $(2)$，设 $\\mathbf{u} \\in \\mathrm{span}(\\mathbf{v}_1, \\ldots, \\mathbf{v}_n)$，则存在 $c_1, \\ldots, c_n \\in F$，使得$$\\mathbf{u} = c_1\\mathbf{v}_1 + \\ldots + c_n\\mathbf{v}_n$$在上面的等式中，可以用之前的等式右边来代替$ \\mathbf{v}_j$。这样 $\\mathbf{u} $包含于从 $(\\mathbf{v}_0, \\ldots, \\mathbf{v}_n)$ 去掉第 $j$ 项的张成，因而 $(2)$ 成立。 线性基 对于一个十进制数 $a$，我们将其转换为二进制得到 $(b_m\\dots b_0)_2$。然后将转换后的二进制看作是一个向量，则得到$\\mathbf a = (b_m,b_{m-1},\\dots,b_0)$。方便起见，我们称向量 $\\mathbf a$ 的第 $i$ 位为 $b_i$。 向量组 $\\mathbf a_1,\\dots\\mathbf a_n$ 可以张成一个向量集合 $\\mathrm{span}(\\mathbf a_1,\\dots,\\mathbf a_n)$，则可以得到一个线性空间 $\\mathrm V = ({0,1},\\mathrm{span}(\\mathbf a_1,\\dots,\\mathbf a_n),\\oplus,\\cdot)$。 按照以下的方法得到这个线性空间的一个基 $\\mathfrak B = (\\mathbf a_1,\\dots,\\mathbf a_n)$ ： 第 $1$ 步：如果 $\\mathbf a_1 = \\mathbf 0$，则从 $\\mathfrak B$ 中去除 $\\mathbf a_1$，否则保持 $\\mathfrak B$ 不变。 第 $j$ 步：如果 $\\mathbf a_j \\in \\mathrm{span}(\\mathbf a_1, \\dots ,\\mathbf a_{j - 1})$ ，则从 $\\mathfrak B$ 中去掉 $\\mathbf a_j$，否则保持 $\\mathfrak B$ 不变。 经过 $n$ 步后终止程序，得到一个向量组 $\\mathfrak B$。由于每一次去掉的项包含于前面诸向量的张成，到最后这个组 $\\mathfrak B$ 仍然可以张成 $\\mathrm V$。而且这一程序确保了 $\\mathfrak B$ 中的任何向量都不包含于它前面诸向量的张成，根据线性相关性引理可知 $\\mathfrak B$ 是线性无关的。于是 $\\mathfrak B$ 是 $\\mathrm V$ 的一个基。 利用高斯消元来判断向量能否被前面的向量张成，就可以写出下面的程序 1234567891011121314151617181920212223#define MAX_BASE 63 // 当数据为long long型时，int型为31void cal(){ for(int i = 0; i &lt; n; i++){ for(int j = MAX_BASE; j &gt;= 0; j--){ if(a[i] &gt;&gt; j &amp; 1){ if(b[j]) a[i] ^= b[j]; else{ b[j] = a[i]; for (int k = j - 1; k &gt;= 0; k--){ if (b[k] &amp;&amp; (b[j] &gt;&gt; k &amp; 1)) b[j] ^= b[k]; } for (int k = j + 1; k &lt;= MAX_BASE; k++){ if (b[k] &gt;&gt; j &amp; 1) b[k] ^= b[j]; } break; } } } }4} b[]数组用来记录最后得到的基 $\\mathfrak B$ ；a[]数组为起初的每一个数字，即 $\\mathbf a_1,\\mathbf a_2,\\dots,\\mathbf a_n$。 虽然数组每一个位置存储的是一个int型数字，但实际上表示的是一个二进制向量，为了表述方便，我们称b[i]为数组b[]的第 $i$ 行。 在第 $i$ 步时，从高到低考虑数 $a_i$ 为 $1$ 的二进制位 $j$，如果数组b[]中第 $j$ 行已经存在内容了，我们就不能将$a_i$ 加到b[]中第 $j$ 行这个位置。而为了保证未来加进去的基向量与其他基向量线性无关，将数 $a_i$ 与 $b_i$ 进行异或计算，就可以消掉可用已经存在的基向量来表示的部分。 如果数组b[]中的第 $j$ 行不存在内容（内容为 $0$），则我们可以将（已经被前面步骤处理好的）数 $a_i$ 加入到这一行。此后为了维护对角矩阵，先用下面的行消自己，再用自己消上面的行。 上面代码中，b[j] &gt;&gt; k &amp; 1可以用来判断 $b_j$ 二进制的第 $k$ 位是否为 $1$。为什么需要&amp; 1？如果没有这个操作，我得到的不仅仅是第 $k$ 的信息，&amp; 1可以让结果只保留第 $k$ 位的信息。 我们来模拟一下这个过程。设 $n = 5$，$a = {7, 1, 4, 3, 5}$。矩阵 $\\mathfrak B$ 一开始长这样：$$\\begin{bmatrix}0 &amp;0 &amp;0 \\\\0 &amp;0 &amp;0 \\\\0 &amp;0 &amp;0\\end{bmatrix}$$我们从 $a_1$ 开始，$a_1 = 7 = (111)_2 = \\mathbf a_1$，而 $\\mathfrak B$ 目前为空。所以我就可以直接把他放进去了，因为$j = \\mathrm{$MAX\\_BASE} = 2$，所以我就把他放在了第二行（因为是上三角矩阵，所以最下面的为第 $0$ 行）。$$\\begin{bmatrix}1 &amp;1 &amp;1 \\\\0 &amp;0 &amp;0 \\\\0 &amp;0 &amp;0\\end{bmatrix}$$然后考虑放$a_2$，$a_2 = 1 = (001)_2 = \\mathbf a_2$，在 $j = 2$ 与 $j = 1$ 时都不满足a[i] &gt;&gt; j &amp; 1的条件，所以不进行操作。$j = 0$ 时，第 $0$ 行没内容，所以就直接放在了第 $0$ 行上，于是矩阵就成了：$$\\begin{bmatrix}1 &amp;1 &amp;1 \\\\0 &amp;0 &amp;0 \\\\0 &amp;0 &amp;1\\end{bmatrix}$$然后用下面的行消自己，好的不存在下面的行。再用自己消上面的行，所以第 $2$ 行会消去最后一个 $1$，矩阵变成：$$\\begin{bmatrix}1 &amp;1 &amp;0 \\\\0 &amp;0 &amp;0 \\\\0 &amp;0 &amp;1\\end{bmatrix}$$接下来就轮到了 $a_3$ 了，$a_3 = 4 = (100)_2 = \\mathbf a_3$，在 $j = 2$ 时符合条件，但第 $2$ 行已经有内容了，所以我们进行 $a_3 = a_3 \\oplus b_2$ 的操作，于是 $a_3$ 成了 $(010)_2$ 。$j = 1$ 时有一次满足条件，所以将他放在了第 $1$ 行上，于是矩阵成了：$$\\begin{bmatrix}1 &amp;1 &amp;0 \\\\0 &amp;1 &amp;0 \\\\0 &amp;0 &amp;1\\end{bmatrix}$$然后用下面的行消自己，好的什么都消不了。然后用自己消上面的行，所以第 $2$ 行中间的 $1$ 被消掉了，矩阵变成了：$$\\begin{bmatrix}1 &amp;0 &amp;0 \\\\0 &amp;1 &amp;0 \\\\0 &amp;0 &amp;1\\end{bmatrix}$$接下来谁也进不去了，结束。 那既然已经知道了结果会是一个上三角矩阵为啥我不直接生成一个呢？因为最终生成的 $\\mathfrak B$ 很有可能不是一个满的上三角矩阵，比如这个样子的：$$\\begin{bmatrix}1 &amp;0 &amp;1&amp;0 \\\\0 &amp;1 &amp;0 &amp;0 \\\\0 &amp;0 &amp;0 &amp;0 \\\\0 &amp;0 &amp;0 &amp;1\\end{bmatrix}$$这样所有被选上的 $\\mathbf a_i$ 构成了一个向量空间 $\\mathrm V$ 的一个基 $\\mathfrak B$，同样矩阵 $b$ 的每一个非 $\\mathbf 0$ 向量 $\\mathbf b_i$ 组成的基也是向量空间 $\\mathrm V$ 的基。我们所指的线性基，特指高斯消元解出的对角矩阵的非零行构成的向量组。如果矩阵的主对角线上第 $i$ 行的元素为 $1$，此时我们称第 $i$ 位存在于线性基中。对于存在于线性基的二进制位，有一个重要的性质：$$对于任意存在于线性基的二进制位\\ i ，至多只有一个\\ \\mathbf b_j\\ 满足第\\ i\\ 位为\\ 1。$$因为我们已经在得到线性基的过程中，不断地使用每一个向量来对上下进行消除，所以 $\\mathbf b_j$ 一定消去了别的向量第 $i$ 位上的 $1$，所以二进制位 $i$ 只存在于 $\\mathbf b_j$ 上。而对于不再线性基中的二进制位 $i$，那么主对角线第 $i$ 行位以下的全部为 $0$， 而上方就可能会有若干个 $1$。 线性基的应用线性基的题型相对比较固定，以下几类基本就是线性基了： 最大异或和 第 $k$ 大异或和 / 这些元素的异或和是第几大 求所有异或值的和 例题$(1)$ To xor or not to xor题目连接：https://codeforces.com/problemsets/acmsguru/problem/99999/275 DescriptionThe sequence of non-negative integers $A_1$, $A_2$, …, $A_n$ is given. You are to find some subsequence $Ai_1$, $Ai_2$, …, $Ai_k$ $(1 \\leq i_1 &lt; i_2 &lt; … &lt; i_k \\leq N)$ such, that $Ai_1 \\oplus Ai_2 \\oplus \\dots \\oplus Ai_k$ has a maximum value. InputThe first line of the input file contains the integer number $N$ $(1 \\leq N \\leq 100)$. The second line contains the sequence $A_1, A_2, \\dots , A_n (0 \\leq Ai \\leq 10^{18})$. OutputWrite to the output file a single integer number – the maximum possible value of $Ai_1 \\oplus Ai_2 \\oplus \\dots \\oplus Ai_k$ . Sample test(s)Input123 11 9 5 Output114 很单纯的求最大异或和。根据以上的内容，我们可以求出这个向量空间的一组线性基 $\\mathfrak B$，则最大的异或和就是将线性基中所有的向量异或起来得到的向量所对应的数。证明如下： 最高的二进制位只存在于数值最大的基向量上，所以最大的基向量肯定要被选。运用归纳法，假设前 $i$ 大的都需要选，考虑第 $i + 1$ 大的向量选不选。显然第 $i + 1$ 大的基向量能对异或和贡献它的最高的二进制位 $j$，因为二进制位 $j$ 在之前的异或和中必然为零（因为二进制位 $j$ 只存在于第 $i + 1$ 大的基向量中）。如果不选，之后的所有数对答案的贡献都只能在小于这个二进制位的地方做贡献，总是比选 $i + 1$ 得到的答案小，所以这个数必须选。 AC代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define MAX_BASE 63long long a[101];long long b[MAX_BASE];int n;void cal(){ for(int i = 0; i &lt; n; i++){ for(int j = MAX_BASE; j &gt;= 0; j--){ if(a[i] &gt;&gt; j &amp; 1){ if(b[j]) a[i] ^= b[j]; else{ b[j] = a[i]; for (int k = j - 1; k &gt;= 0; k--){ if (b[k] &amp;&amp; (b[j] &gt;&gt; k &amp; 1)) b[j] ^= b[k]; } for (int k = j + 1; k &lt;= MAX_BASE; k++){ if (b[k] &gt;&gt; j &amp; 1) b[k] ^= b[j]; } break; } } } }}int main(){ scanf(\"%d\" ,&amp;n); memset(b, 0, sizeof(b)); memset(choice, 0, sizeof(choice)); for (int i = 0; i &lt; n; i++) { scanf(\"%lld\", &amp;a[i]); } cal(); long long ans = 0; for (int i = 0; i &lt;= MAX_BASE; i++) { if(b[i]){ ans ^= b[i]; } } printf(\"%lld\\n\", ans);}","link":"/2019/07/27/线性基（异或和求最大值）/"}],"tags":[{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"Solution","slug":"Solution","link":"/tags/Solution/"},{"name":"Learning Note","slug":"Learning-Note","link":"/tags/Learning-Note/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"}],"categories":[{"name":"Solution","slug":"Solution","link":"/categories/Solution/"},{"name":"Algorithm study","slug":"Algorithm-study","link":"/categories/Algorithm-study/"},{"name":"Blog","slug":"Blog","link":"/categories/Blog/"}]}